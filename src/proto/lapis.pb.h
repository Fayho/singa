// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lapis.proto

#ifndef PROTOBUF_lapis_2eproto__INCLUDED
#define PROTOBUF_lapis_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace lapis {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_lapis_2eproto();
void protobuf_AssignDesc_lapis_2eproto();
void protobuf_ShutdownFile_lapis_2eproto();

class SystemConfProto;
class DataSourceProto;
class RGBDatum;
class ParamProto;
class EdgeProto;
class LayerProto;
class NetProto;
class SGDProto;
class PerformanceProto;
class TrainerProto;
class ModelConfProto;

enum DataSourceProto_DataType {
  DataSourceProto_DataType_FEATURE = 0,
  DataSourceProto_DataType_LABEL = 1
};
bool DataSourceProto_DataType_IsValid(int value);
const DataSourceProto_DataType DataSourceProto_DataType_DataType_MIN = DataSourceProto_DataType_FEATURE;
const DataSourceProto_DataType DataSourceProto_DataType_DataType_MAX = DataSourceProto_DataType_LABEL;
const int DataSourceProto_DataType_DataType_ARRAYSIZE = DataSourceProto_DataType_DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataSourceProto_DataType_descriptor();
inline const ::std::string& DataSourceProto_DataType_Name(DataSourceProto_DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataSourceProto_DataType_descriptor(), value);
}
inline bool DataSourceProto_DataType_Parse(
    const ::std::string& name, DataSourceProto_DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataSourceProto_DataType>(
    DataSourceProto_DataType_descriptor(), name, value);
}
enum SGDProto_ChangeProto {
  SGDProto_ChangeProto_FIXED = 0,
  SGDProto_ChangeProto_INVERSE_T = 1,
  SGDProto_ChangeProto_EXPONENTIAL = 2,
  SGDProto_ChangeProto_LINEAR = 3
};
bool SGDProto_ChangeProto_IsValid(int value);
const SGDProto_ChangeProto SGDProto_ChangeProto_ChangeProto_MIN = SGDProto_ChangeProto_FIXED;
const SGDProto_ChangeProto SGDProto_ChangeProto_ChangeProto_MAX = SGDProto_ChangeProto_LINEAR;
const int SGDProto_ChangeProto_ChangeProto_ARRAYSIZE = SGDProto_ChangeProto_ChangeProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* SGDProto_ChangeProto_descriptor();
inline const ::std::string& SGDProto_ChangeProto_Name(SGDProto_ChangeProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    SGDProto_ChangeProto_descriptor(), value);
}
inline bool SGDProto_ChangeProto_Parse(
    const ::std::string& name, SGDProto_ChangeProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SGDProto_ChangeProto>(
    SGDProto_ChangeProto_descriptor(), name, value);
}
// ===================================================================

class SystemConfProto : public ::google::protobuf::Message {
 public:
  SystemConfProto();
  virtual ~SystemConfProto();

  SystemConfProto(const SystemConfProto& from);

  inline SystemConfProto& operator=(const SystemConfProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemConfProto& default_instance();

  void Swap(SystemConfProto* other);

  // implements Message ----------------------------------------------

  SystemConfProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemConfProto& from);
  void MergeFrom(const SystemConfProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 coordinator = 1;
  inline bool has_coordinator() const;
  inline void clear_coordinator();
  static const int kCoordinatorFieldNumber = 1;
  inline ::google::protobuf::int32 coordinator() const;
  inline void set_coordinator(::google::protobuf::int32 value);

  // required int32 worker_start = 2;
  inline bool has_worker_start() const;
  inline void clear_worker_start();
  static const int kWorkerStartFieldNumber = 2;
  inline ::google::protobuf::int32 worker_start() const;
  inline void set_worker_start(::google::protobuf::int32 value);

  // required int32 worker_end = 3;
  inline bool has_worker_end() const;
  inline void clear_worker_end();
  static const int kWorkerEndFieldNumber = 3;
  inline ::google::protobuf::int32 worker_end() const;
  inline void set_worker_end(::google::protobuf::int32 value);

  // optional int32 memory_start = 4;
  inline bool has_memory_start() const;
  inline void clear_memory_start();
  static const int kMemoryStartFieldNumber = 4;
  inline ::google::protobuf::int32 memory_start() const;
  inline void set_memory_start(::google::protobuf::int32 value);

  // optional int32 memory_end = 5;
  inline bool has_memory_end() const;
  inline void clear_memory_end();
  static const int kMemoryEndFieldNumber = 5;
  inline ::google::protobuf::int32 memory_end() const;
  inline void set_memory_end(::google::protobuf::int32 value);

  // optional int32 disk_start = 6;
  inline bool has_disk_start() const;
  inline void clear_disk_start();
  static const int kDiskStartFieldNumber = 6;
  inline ::google::protobuf::int32 disk_start() const;
  inline void set_disk_start(::google::protobuf::int32 value);

  // optional int32 disk_end = 7;
  inline bool has_disk_end() const;
  inline void clear_disk_end();
  static const int kDiskEndFieldNumber = 7;
  inline ::google::protobuf::int32 disk_end() const;
  inline void set_disk_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lapis.SystemConfProto)
 private:
  inline void set_has_coordinator();
  inline void clear_has_coordinator();
  inline void set_has_worker_start();
  inline void clear_has_worker_start();
  inline void set_has_worker_end();
  inline void clear_has_worker_end();
  inline void set_has_memory_start();
  inline void clear_has_memory_start();
  inline void set_has_memory_end();
  inline void clear_has_memory_end();
  inline void set_has_disk_start();
  inline void clear_has_disk_start();
  inline void set_has_disk_end();
  inline void clear_has_disk_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 coordinator_;
  ::google::protobuf::int32 worker_start_;
  ::google::protobuf::int32 worker_end_;
  ::google::protobuf::int32 memory_start_;
  ::google::protobuf::int32 memory_end_;
  ::google::protobuf::int32 disk_start_;
  ::google::protobuf::int32 disk_end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_lapis_2eproto();
  friend void protobuf_AssignDesc_lapis_2eproto();
  friend void protobuf_ShutdownFile_lapis_2eproto();

  void InitAsDefaultInstance();
  static SystemConfProto* default_instance_;
};
// -------------------------------------------------------------------

class DataSourceProto : public ::google::protobuf::Message {
 public:
  DataSourceProto();
  virtual ~DataSourceProto();

  DataSourceProto(const DataSourceProto& from);

  inline DataSourceProto& operator=(const DataSourceProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataSourceProto& default_instance();

  void Swap(DataSourceProto* other);

  // implements Message ----------------------------------------------

  DataSourceProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataSourceProto& from);
  void MergeFrom(const DataSourceProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DataSourceProto_DataType DataType;
  static const DataType FEATURE = DataSourceProto_DataType_FEATURE;
  static const DataType LABEL = DataSourceProto_DataType_LABEL;
  static inline bool DataType_IsValid(int value) {
    return DataSourceProto_DataType_IsValid(value);
  }
  static const DataType DataType_MIN =
    DataSourceProto_DataType_DataType_MIN;
  static const DataType DataType_MAX =
    DataSourceProto_DataType_DataType_MAX;
  static const int DataType_ARRAYSIZE =
    DataSourceProto_DataType_DataType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DataType_descriptor() {
    return DataSourceProto_DataType_descriptor();
  }
  static inline const ::std::string& DataType_Name(DataType value) {
    return DataSourceProto_DataType_Name(value);
  }
  static inline bool DataType_Parse(const ::std::string& name,
      DataType* value) {
    return DataSourceProto_DataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string parser = 2;
  inline bool has_parser() const;
  inline void clear_parser();
  static const int kParserFieldNumber = 2;
  inline const ::std::string& parser() const;
  inline void set_parser(const ::std::string& value);
  inline void set_parser(const char* value);
  inline void set_parser(const char* value, size_t size);
  inline ::std::string* mutable_parser();
  inline ::std::string* release_parser();
  inline void set_allocated_parser(::std::string* parser);

  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional int64 size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // optional int64 num = 5;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 5;
  inline ::google::protobuf::int64 num() const;
  inline void set_num(::google::protobuf::int64 value);

  // optional .lapis.DataSourceProto.DataType type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::lapis::DataSourceProto_DataType type() const;
  inline void set_type(::lapis::DataSourceProto_DataType value);

  // optional int32 channels = 7;
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 7;
  inline ::google::protobuf::int32 channels() const;
  inline void set_channels(::google::protobuf::int32 value);

  // optional int32 height = 8;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 8;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 width = 9;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 9;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lapis.DataSourceProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_parser();
  inline void clear_has_parser();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* parser_;
  ::std::string* path_;
  ::google::protobuf::int64 size_;
  ::google::protobuf::int64 num_;
  int type_;
  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 width_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_lapis_2eproto();
  friend void protobuf_AssignDesc_lapis_2eproto();
  friend void protobuf_ShutdownFile_lapis_2eproto();

  void InitAsDefaultInstance();
  static DataSourceProto* default_instance_;
};
// -------------------------------------------------------------------

class RGBDatum : public ::google::protobuf::Message {
 public:
  RGBDatum();
  virtual ~RGBDatum();

  RGBDatum(const RGBDatum& from);

  inline RGBDatum& operator=(const RGBDatum& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RGBDatum& default_instance();

  void Swap(RGBDatum* other);

  // implements Message ----------------------------------------------

  RGBDatum* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RGBDatum& from);
  void MergeFrom(const RGBDatum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 channels = 1 [default = 3];
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 1;
  inline ::google::protobuf::int32 channels() const;
  inline void set_channels(::google::protobuf::int32 value);

  // optional int32 height = 2 [default = 0];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 width = 3 [default = 0];
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required string content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:lapis.RGBDatum)
 private:
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 height_;
  ::std::string* content_;
  ::google::protobuf::int32 width_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_lapis_2eproto();
  friend void protobuf_AssignDesc_lapis_2eproto();
  friend void protobuf_ShutdownFile_lapis_2eproto();

  void InitAsDefaultInstance();
  static RGBDatum* default_instance_;
};
// -------------------------------------------------------------------

class ParamProto : public ::google::protobuf::Message {
 public:
  ParamProto();
  virtual ~ParamProto();

  ParamProto(const ParamProto& from);

  inline ParamProto& operator=(const ParamProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParamProto& default_instance();

  void Swap(ParamProto* other);

  // implements Message ----------------------------------------------

  ParamProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParamProto& from);
  void MergeFrom(const ParamProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string initializer = 2 [default = "Zero"];
  inline bool has_initializer() const;
  inline void clear_initializer();
  static const int kInitializerFieldNumber = 2;
  inline const ::std::string& initializer() const;
  inline void set_initializer(const ::std::string& value);
  inline void set_initializer(const char* value);
  inline void set_initializer(const char* value, size_t size);
  inline ::std::string* mutable_initializer();
  inline ::std::string* release_initializer();
  inline void set_allocated_initializer(::std::string* initializer);

  // repeated int32 shape = 3;
  inline int shape_size() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 3;
  inline ::google::protobuf::int32 shape(int index) const;
  inline void set_shape(int index, ::google::protobuf::int32 value);
  inline void add_shape(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shape() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shape();

  // optional string partitioner = 4;
  inline bool has_partitioner() const;
  inline void clear_partitioner();
  static const int kPartitionerFieldNumber = 4;
  inline const ::std::string& partitioner() const;
  inline void set_partitioner(const ::std::string& value);
  inline void set_partitioner(const char* value);
  inline void set_partitioner(const char* value, size_t size);
  inline ::std::string* mutable_partitioner();
  inline ::std::string* release_partitioner();
  inline void set_allocated_partitioner(::std::string* partitioner);

  // repeated float content = 5 [packed = true];
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline float content(int index) const;
  inline void set_content(int index, float value);
  inline void add_content(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      content() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_content();

  // @@protoc_insertion_point(class_scope:lapis.ParamProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_initializer();
  inline void clear_has_initializer();
  inline void set_has_partitioner();
  inline void clear_has_partitioner();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* initializer_;
  static ::std::string* _default_initializer_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shape_;
  ::std::string* partitioner_;
  ::google::protobuf::RepeatedField< float > content_;
  mutable int _content_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_lapis_2eproto();
  friend void protobuf_AssignDesc_lapis_2eproto();
  friend void protobuf_ShutdownFile_lapis_2eproto();

  void InitAsDefaultInstance();
  static ParamProto* default_instance_;
};
// -------------------------------------------------------------------

class EdgeProto : public ::google::protobuf::Message {
 public:
  EdgeProto();
  virtual ~EdgeProto();

  EdgeProto(const EdgeProto& from);

  inline EdgeProto& operator=(const EdgeProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeProto& default_instance();

  void Swap(EdgeProto* other);

  // implements Message ----------------------------------------------

  EdgeProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EdgeProto& from);
  void MergeFrom(const EdgeProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // repeated .lapis.ParamProto param = 3;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 3;
  inline const ::lapis::ParamProto& param(int index) const;
  inline ::lapis::ParamProto* mutable_param(int index);
  inline ::lapis::ParamProto* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto >*
      mutable_param();

  // optional bool directed = 4 [default = true];
  inline bool has_directed() const;
  inline void clear_directed();
  static const int kDirectedFieldNumber = 4;
  inline bool directed() const;
  inline void set_directed(bool value);

  // @@protoc_insertion_point(class_scope:lapis.EdgeProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_directed();
  inline void clear_has_directed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* type_;
  ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto > param_;
  bool directed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_lapis_2eproto();
  friend void protobuf_AssignDesc_lapis_2eproto();
  friend void protobuf_ShutdownFile_lapis_2eproto();

  void InitAsDefaultInstance();
  static EdgeProto* default_instance_;
};
// -------------------------------------------------------------------

class LayerProto : public ::google::protobuf::Message {
 public:
  LayerProto();
  virtual ~LayerProto();

  LayerProto(const LayerProto& from);

  inline LayerProto& operator=(const LayerProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LayerProto& default_instance();

  void Swap(LayerProto* other);

  // implements Message ----------------------------------------------

  LayerProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LayerProto& from);
  void MergeFrom(const LayerProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 num_output = 2;
  inline bool has_num_output() const;
  inline void clear_num_output();
  static const int kNumOutputFieldNumber = 2;
  inline ::google::protobuf::int32 num_output() const;
  inline void set_num_output(::google::protobuf::int32 value);

  // required string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // repeated .lapis.ParamProto param = 4;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 4;
  inline const ::lapis::ParamProto& param(int index) const;
  inline ::lapis::ParamProto* mutable_param(int index);
  inline ::lapis::ParamProto* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto >*
      mutable_param();

  // repeated string out_edge = 5;
  inline int out_edge_size() const;
  inline void clear_out_edge();
  static const int kOutEdgeFieldNumber = 5;
  inline const ::std::string& out_edge(int index) const;
  inline ::std::string* mutable_out_edge(int index);
  inline void set_out_edge(int index, const ::std::string& value);
  inline void set_out_edge(int index, const char* value);
  inline void set_out_edge(int index, const char* value, size_t size);
  inline ::std::string* add_out_edge();
  inline void add_out_edge(const ::std::string& value);
  inline void add_out_edge(const char* value);
  inline void add_out_edge(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& out_edge() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_out_edge();

  // repeated string in_edge = 6;
  inline int in_edge_size() const;
  inline void clear_in_edge();
  static const int kInEdgeFieldNumber = 6;
  inline const ::std::string& in_edge(int index) const;
  inline ::std::string* mutable_in_edge(int index);
  inline void set_in_edge(int index, const ::std::string& value);
  inline void set_in_edge(int index, const char* value);
  inline void set_in_edge(int index, const char* value, size_t size);
  inline ::std::string* add_in_edge();
  inline void add_in_edge(const ::std::string& value);
  inline void add_in_edge(const char* value);
  inline void add_in_edge(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& in_edge() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_in_edge();

  // @@protoc_insertion_point(class_scope:lapis.LayerProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_num_output();
  inline void clear_has_num_output();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* type_;
  ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto > param_;
  ::google::protobuf::RepeatedPtrField< ::std::string> out_edge_;
  ::google::protobuf::RepeatedPtrField< ::std::string> in_edge_;
  ::google::protobuf::int32 num_output_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_lapis_2eproto();
  friend void protobuf_AssignDesc_lapis_2eproto();
  friend void protobuf_ShutdownFile_lapis_2eproto();

  void InitAsDefaultInstance();
  static LayerProto* default_instance_;
};
// -------------------------------------------------------------------

class NetProto : public ::google::protobuf::Message {
 public:
  NetProto();
  virtual ~NetProto();

  NetProto(const NetProto& from);

  inline NetProto& operator=(const NetProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetProto& default_instance();

  void Swap(NetProto* other);

  // implements Message ----------------------------------------------

  NetProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetProto& from);
  void MergeFrom(const NetProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lapis.LayerProto layer = 3;
  inline int layer_size() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 3;
  inline const ::lapis::LayerProto& layer(int index) const;
  inline ::lapis::LayerProto* mutable_layer(int index);
  inline ::lapis::LayerProto* add_layer();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::LayerProto >&
      layer() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::LayerProto >*
      mutable_layer();

  // repeated .lapis.EdgeProto edge = 4;
  inline int edge_size() const;
  inline void clear_edge();
  static const int kEdgeFieldNumber = 4;
  inline const ::lapis::EdgeProto& edge(int index) const;
  inline ::lapis::EdgeProto* mutable_edge(int index);
  inline ::lapis::EdgeProto* add_edge();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::EdgeProto >&
      edge() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::EdgeProto >*
      mutable_edge();

  // @@protoc_insertion_point(class_scope:lapis.NetProto)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::lapis::LayerProto > layer_;
  ::google::protobuf::RepeatedPtrField< ::lapis::EdgeProto > edge_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_lapis_2eproto();
  friend void protobuf_AssignDesc_lapis_2eproto();
  friend void protobuf_ShutdownFile_lapis_2eproto();

  void InitAsDefaultInstance();
  static NetProto* default_instance_;
};
// -------------------------------------------------------------------

class SGDProto : public ::google::protobuf::Message {
 public:
  SGDProto();
  virtual ~SGDProto();

  SGDProto(const SGDProto& from);

  inline SGDProto& operator=(const SGDProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SGDProto& default_instance();

  void Swap(SGDProto* other);

  // implements Message ----------------------------------------------

  SGDProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SGDProto& from);
  void MergeFrom(const SGDProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SGDProto_ChangeProto ChangeProto;
  static const ChangeProto FIXED = SGDProto_ChangeProto_FIXED;
  static const ChangeProto INVERSE_T = SGDProto_ChangeProto_INVERSE_T;
  static const ChangeProto EXPONENTIAL = SGDProto_ChangeProto_EXPONENTIAL;
  static const ChangeProto LINEAR = SGDProto_ChangeProto_LINEAR;
  static inline bool ChangeProto_IsValid(int value) {
    return SGDProto_ChangeProto_IsValid(value);
  }
  static const ChangeProto ChangeProto_MIN =
    SGDProto_ChangeProto_ChangeProto_MIN;
  static const ChangeProto ChangeProto_MAX =
    SGDProto_ChangeProto_ChangeProto_MAX;
  static const int ChangeProto_ARRAYSIZE =
    SGDProto_ChangeProto_ChangeProto_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ChangeProto_descriptor() {
    return SGDProto_ChangeProto_descriptor();
  }
  static inline const ::std::string& ChangeProto_Name(ChangeProto value) {
    return SGDProto_ChangeProto_Name(value);
  }
  static inline bool ChangeProto_Parse(const ::std::string& name,
      ChangeProto* value) {
    return SGDProto_ChangeProto_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required float base_learning_rate = 1;
  inline bool has_base_learning_rate() const;
  inline void clear_base_learning_rate();
  static const int kBaseLearningRateFieldNumber = 1;
  inline float base_learning_rate() const;
  inline void set_base_learning_rate(float value);

  // optional float base_momentum = 2 [default = 0];
  inline bool has_base_momentum() const;
  inline void clear_base_momentum();
  static const int kBaseMomentumFieldNumber = 2;
  inline float base_momentum() const;
  inline void set_base_momentum(float value);

  // optional float base_weight_decay = 3 [default = 0];
  inline bool has_base_weight_decay() const;
  inline void clear_base_weight_decay();
  static const int kBaseWeightDecayFieldNumber = 3;
  inline float base_weight_decay() const;
  inline void set_base_weight_decay(float value);

  // optional float final_momentum = 4;
  inline bool has_final_momentum() const;
  inline void clear_final_momentum();
  static const int kFinalMomentumFieldNumber = 4;
  inline float final_momentum() const;
  inline void set_final_momentum(float value);

  // optional float final_learning_rate = 5;
  inline bool has_final_learning_rate() const;
  inline void clear_final_learning_rate();
  static const int kFinalLearningRateFieldNumber = 5;
  inline float final_learning_rate() const;
  inline void set_final_learning_rate(float value);

  // optional float final_weight_decay = 6;
  inline bool has_final_weight_decay() const;
  inline void clear_final_weight_decay();
  static const int kFinalWeightDecayFieldNumber = 6;
  inline float final_weight_decay() const;
  inline void set_final_weight_decay(float value);

  // optional int32 learning_rate_change_steps = 7;
  inline bool has_learning_rate_change_steps() const;
  inline void clear_learning_rate_change_steps();
  static const int kLearningRateChangeStepsFieldNumber = 7;
  inline ::google::protobuf::int32 learning_rate_change_steps() const;
  inline void set_learning_rate_change_steps(::google::protobuf::int32 value);

  // optional int32 momentum_change_steps = 8;
  inline bool has_momentum_change_steps() const;
  inline void clear_momentum_change_steps();
  static const int kMomentumChangeStepsFieldNumber = 8;
  inline ::google::protobuf::int32 momentum_change_steps() const;
  inline void set_momentum_change_steps(::google::protobuf::int32 value);

  // optional int32 weight_decay_change_steps = 9;
  inline bool has_weight_decay_change_steps() const;
  inline void clear_weight_decay_change_steps();
  static const int kWeightDecayChangeStepsFieldNumber = 9;
  inline ::google::protobuf::int32 weight_decay_change_steps() const;
  inline void set_weight_decay_change_steps(::google::protobuf::int32 value);

  // optional .lapis.SGDProto.ChangeProto learning_rate_change = 10 [default = INVERSE_T];
  inline bool has_learning_rate_change() const;
  inline void clear_learning_rate_change();
  static const int kLearningRateChangeFieldNumber = 10;
  inline ::lapis::SGDProto_ChangeProto learning_rate_change() const;
  inline void set_learning_rate_change(::lapis::SGDProto_ChangeProto value);

  // optional .lapis.SGDProto.ChangeProto weight_decay_change = 11 [default = FIXED];
  inline bool has_weight_decay_change() const;
  inline void clear_weight_decay_change();
  static const int kWeightDecayChangeFieldNumber = 11;
  inline ::lapis::SGDProto_ChangeProto weight_decay_change() const;
  inline void set_weight_decay_change(::lapis::SGDProto_ChangeProto value);

  // optional .lapis.SGDProto.ChangeProto momentum_change = 12 [default = FIXED];
  inline bool has_momentum_change() const;
  inline void clear_momentum_change();
  static const int kMomentumChangeFieldNumber = 12;
  inline ::lapis::SGDProto_ChangeProto momentum_change() const;
  inline void set_momentum_change(::lapis::SGDProto_ChangeProto value);

  // optional int32 total_steps = 13;
  inline bool has_total_steps() const;
  inline void clear_total_steps();
  static const int kTotalStepsFieldNumber = 13;
  inline ::google::protobuf::int32 total_steps() const;
  inline void set_total_steps(::google::protobuf::int32 value);

  // optional int32 batchsize = 14;
  inline bool has_batchsize() const;
  inline void clear_batchsize();
  static const int kBatchsizeFieldNumber = 14;
  inline ::google::protobuf::int32 batchsize() const;
  inline void set_batchsize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lapis.SGDProto)
 private:
  inline void set_has_base_learning_rate();
  inline void clear_has_base_learning_rate();
  inline void set_has_base_momentum();
  inline void clear_has_base_momentum();
  inline void set_has_base_weight_decay();
  inline void clear_has_base_weight_decay();
  inline void set_has_final_momentum();
  inline void clear_has_final_momentum();
  inline void set_has_final_learning_rate();
  inline void clear_has_final_learning_rate();
  inline void set_has_final_weight_decay();
  inline void clear_has_final_weight_decay();
  inline void set_has_learning_rate_change_steps();
  inline void clear_has_learning_rate_change_steps();
  inline void set_has_momentum_change_steps();
  inline void clear_has_momentum_change_steps();
  inline void set_has_weight_decay_change_steps();
  inline void clear_has_weight_decay_change_steps();
  inline void set_has_learning_rate_change();
  inline void clear_has_learning_rate_change();
  inline void set_has_weight_decay_change();
  inline void clear_has_weight_decay_change();
  inline void set_has_momentum_change();
  inline void clear_has_momentum_change();
  inline void set_has_total_steps();
  inline void clear_has_total_steps();
  inline void set_has_batchsize();
  inline void clear_has_batchsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float base_learning_rate_;
  float base_momentum_;
  float base_weight_decay_;
  float final_momentum_;
  float final_learning_rate_;
  float final_weight_decay_;
  ::google::protobuf::int32 learning_rate_change_steps_;
  ::google::protobuf::int32 momentum_change_steps_;
  ::google::protobuf::int32 weight_decay_change_steps_;
  int learning_rate_change_;
  int weight_decay_change_;
  int momentum_change_;
  ::google::protobuf::int32 total_steps_;
  ::google::protobuf::int32 batchsize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_lapis_2eproto();
  friend void protobuf_AssignDesc_lapis_2eproto();
  friend void protobuf_ShutdownFile_lapis_2eproto();

  void InitAsDefaultInstance();
  static SGDProto* default_instance_;
};
// -------------------------------------------------------------------

class PerformanceProto : public ::google::protobuf::Message {
 public:
  PerformanceProto();
  virtual ~PerformanceProto();

  PerformanceProto(const PerformanceProto& from);

  inline PerformanceProto& operator=(const PerformanceProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerformanceProto& default_instance();

  void Swap(PerformanceProto* other);

  // implements Message ----------------------------------------------

  PerformanceProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PerformanceProto& from);
  void MergeFrom(const PerformanceProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float precision = 1;
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 1;
  inline float precision() const;
  inline void set_precision(float value);

  // optional float recall = 2;
  inline bool has_recall() const;
  inline void clear_recall();
  static const int kRecallFieldNumber = 2;
  inline float recall() const;
  inline void set_recall(float value);

  // optional float map = 3;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 3;
  inline float map() const;
  inline void set_map(float value);

  // optional float precision50 = 4;
  inline bool has_precision50() const;
  inline void clear_precision50();
  static const int kPrecision50FieldNumber = 4;
  inline float precision50() const;
  inline void set_precision50(float value);

  // @@protoc_insertion_point(class_scope:lapis.PerformanceProto)
 private:
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_recall();
  inline void clear_has_recall();
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_precision50();
  inline void clear_has_precision50();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float precision_;
  float recall_;
  float map_;
  float precision50_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_lapis_2eproto();
  friend void protobuf_AssignDesc_lapis_2eproto();
  friend void protobuf_ShutdownFile_lapis_2eproto();

  void InitAsDefaultInstance();
  static PerformanceProto* default_instance_;
};
// -------------------------------------------------------------------

class TrainerProto : public ::google::protobuf::Message {
 public:
  TrainerProto();
  virtual ~TrainerProto();

  TrainerProto(const TrainerProto& from);

  inline TrainerProto& operator=(const TrainerProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrainerProto& default_instance();

  void Swap(TrainerProto* other);

  // implements Message ----------------------------------------------

  TrainerProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrainerProto& from);
  void MergeFrom(const TrainerProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .lapis.SGDProto sgd = 1;
  inline bool has_sgd() const;
  inline void clear_sgd();
  static const int kSgdFieldNumber = 1;
  inline const ::lapis::SGDProto& sgd() const;
  inline ::lapis::SGDProto* mutable_sgd();
  inline ::lapis::SGDProto* release_sgd();
  inline void set_allocated_sgd(::lapis::SGDProto* sgd);

  // optional int32 checkpoint_after_steps = 2 [default = 0];
  inline bool has_checkpoint_after_steps() const;
  inline void clear_checkpoint_after_steps();
  static const int kCheckpointAfterStepsFieldNumber = 2;
  inline ::google::protobuf::int32 checkpoint_after_steps() const;
  inline void set_checkpoint_after_steps(::google::protobuf::int32 value);

  // optional int32 checkpoint_every_steps = 3 [default = 0];
  inline bool has_checkpoint_every_steps() const;
  inline void clear_checkpoint_every_steps();
  static const int kCheckpointEveryStepsFieldNumber = 3;
  inline ::google::protobuf::int32 checkpoint_every_steps() const;
  inline void set_checkpoint_every_steps(::google::protobuf::int32 value);

  // optional string checkpoint_prefix = 4 [default = "tmp/checkpoint"];
  inline bool has_checkpoint_prefix() const;
  inline void clear_checkpoint_prefix();
  static const int kCheckpointPrefixFieldNumber = 4;
  inline const ::std::string& checkpoint_prefix() const;
  inline void set_checkpoint_prefix(const ::std::string& value);
  inline void set_checkpoint_prefix(const char* value);
  inline void set_checkpoint_prefix(const char* value, size_t size);
  inline ::std::string* mutable_checkpoint_prefix();
  inline ::std::string* release_checkpoint_prefix();
  inline void set_allocated_checkpoint_prefix(::std::string* checkpoint_prefix);

  // optional int32 checkpoint_step = 5 [default = 0];
  inline bool has_checkpoint_step() const;
  inline void clear_checkpoint_step();
  static const int kCheckpointStepFieldNumber = 5;
  inline ::google::protobuf::int32 checkpoint_step() const;
  inline void set_checkpoint_step(::google::protobuf::int32 value);

  // optional int32 display_after_steps = 6 [default = 0];
  inline bool has_display_after_steps() const;
  inline void clear_display_after_steps();
  static const int kDisplayAfterStepsFieldNumber = 6;
  inline ::google::protobuf::int32 display_after_steps() const;
  inline void set_display_after_steps(::google::protobuf::int32 value);

  // optional int32 display_every_steps = 7 [default = 0];
  inline bool has_display_every_steps() const;
  inline void clear_display_every_steps();
  static const int kDisplayEveryStepsFieldNumber = 7;
  inline ::google::protobuf::int32 display_every_steps() const;
  inline void set_display_every_steps(::google::protobuf::int32 value);

  // optional string display_prefix = 8 [default = "tmp/display"];
  inline bool has_display_prefix() const;
  inline void clear_display_prefix();
  static const int kDisplayPrefixFieldNumber = 8;
  inline const ::std::string& display_prefix() const;
  inline void set_display_prefix(const ::std::string& value);
  inline void set_display_prefix(const char* value);
  inline void set_display_prefix(const char* value, size_t size);
  inline ::std::string* mutable_display_prefix();
  inline ::std::string* release_display_prefix();
  inline void set_allocated_display_prefix(::std::string* display_prefix);

  // repeated .lapis.DataSourceProto train_data = 9;
  inline int train_data_size() const;
  inline void clear_train_data();
  static const int kTrainDataFieldNumber = 9;
  inline const ::lapis::DataSourceProto& train_data(int index) const;
  inline ::lapis::DataSourceProto* mutable_train_data(int index);
  inline ::lapis::DataSourceProto* add_train_data();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >&
      train_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >*
      mutable_train_data();

  // repeated .lapis.DataSourceProto validation_data = 10;
  inline int validation_data_size() const;
  inline void clear_validation_data();
  static const int kValidationDataFieldNumber = 10;
  inline const ::lapis::DataSourceProto& validation_data(int index) const;
  inline ::lapis::DataSourceProto* mutable_validation_data(int index);
  inline ::lapis::DataSourceProto* add_validation_data();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >&
      validation_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >*
      mutable_validation_data();

  // repeated .lapis.DataSourceProto test_data = 11;
  inline int test_data_size() const;
  inline void clear_test_data();
  static const int kTestDataFieldNumber = 11;
  inline const ::lapis::DataSourceProto& test_data(int index) const;
  inline ::lapis::DataSourceProto* mutable_test_data(int index);
  inline ::lapis::DataSourceProto* add_test_data();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >&
      test_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >*
      mutable_test_data();

  // optional string perf_prefix = 14 [default = "tmp/performance"];
  inline bool has_perf_prefix() const;
  inline void clear_perf_prefix();
  static const int kPerfPrefixFieldNumber = 14;
  inline const ::std::string& perf_prefix() const;
  inline void set_perf_prefix(const ::std::string& value);
  inline void set_perf_prefix(const char* value);
  inline void set_perf_prefix(const char* value, size_t size);
  inline ::std::string* mutable_perf_prefix();
  inline ::std::string* release_perf_prefix();
  inline void set_allocated_perf_prefix(::std::string* perf_prefix);

  // @@protoc_insertion_point(class_scope:lapis.TrainerProto)
 private:
  inline void set_has_sgd();
  inline void clear_has_sgd();
  inline void set_has_checkpoint_after_steps();
  inline void clear_has_checkpoint_after_steps();
  inline void set_has_checkpoint_every_steps();
  inline void clear_has_checkpoint_every_steps();
  inline void set_has_checkpoint_prefix();
  inline void clear_has_checkpoint_prefix();
  inline void set_has_checkpoint_step();
  inline void clear_has_checkpoint_step();
  inline void set_has_display_after_steps();
  inline void clear_has_display_after_steps();
  inline void set_has_display_every_steps();
  inline void clear_has_display_every_steps();
  inline void set_has_display_prefix();
  inline void clear_has_display_prefix();
  inline void set_has_perf_prefix();
  inline void clear_has_perf_prefix();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lapis::SGDProto* sgd_;
  ::google::protobuf::int32 checkpoint_after_steps_;
  ::google::protobuf::int32 checkpoint_every_steps_;
  ::std::string* checkpoint_prefix_;
  static ::std::string* _default_checkpoint_prefix_;
  ::google::protobuf::int32 checkpoint_step_;
  ::google::protobuf::int32 display_after_steps_;
  ::std::string* display_prefix_;
  static ::std::string* _default_display_prefix_;
  ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto > train_data_;
  ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto > validation_data_;
  ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto > test_data_;
  ::std::string* perf_prefix_;
  static ::std::string* _default_perf_prefix_;
  ::google::protobuf::int32 display_every_steps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_lapis_2eproto();
  friend void protobuf_AssignDesc_lapis_2eproto();
  friend void protobuf_ShutdownFile_lapis_2eproto();

  void InitAsDefaultInstance();
  static TrainerProto* default_instance_;
};
// -------------------------------------------------------------------

class ModelConfProto : public ::google::protobuf::Message {
 public:
  ModelConfProto();
  virtual ~ModelConfProto();

  ModelConfProto(const ModelConfProto& from);

  inline ModelConfProto& operator=(const ModelConfProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelConfProto& default_instance();

  void Swap(ModelConfProto* other);

  // implements Message ----------------------------------------------

  ModelConfProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelConfProto& from);
  void MergeFrom(const ModelConfProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .lapis.NetProto net = 2;
  inline bool has_net() const;
  inline void clear_net();
  static const int kNetFieldNumber = 2;
  inline const ::lapis::NetProto& net() const;
  inline ::lapis::NetProto* mutable_net();
  inline ::lapis::NetProto* release_net();
  inline void set_allocated_net(::lapis::NetProto* net);

  // required .lapis.TrainerProto trainer = 3;
  inline bool has_trainer() const;
  inline void clear_trainer();
  static const int kTrainerFieldNumber = 3;
  inline const ::lapis::TrainerProto& trainer() const;
  inline ::lapis::TrainerProto* mutable_trainer();
  inline ::lapis::TrainerProto* release_trainer();
  inline void set_allocated_trainer(::lapis::TrainerProto* trainer);

  // @@protoc_insertion_point(class_scope:lapis.ModelConfProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_net();
  inline void clear_has_net();
  inline void set_has_trainer();
  inline void clear_has_trainer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::lapis::NetProto* net_;
  ::lapis::TrainerProto* trainer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_lapis_2eproto();
  friend void protobuf_AssignDesc_lapis_2eproto();
  friend void protobuf_ShutdownFile_lapis_2eproto();

  void InitAsDefaultInstance();
  static ModelConfProto* default_instance_;
};
// ===================================================================


// ===================================================================

// SystemConfProto

// required int32 coordinator = 1;
inline bool SystemConfProto::has_coordinator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemConfProto::set_has_coordinator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemConfProto::clear_has_coordinator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemConfProto::clear_coordinator() {
  coordinator_ = 0;
  clear_has_coordinator();
}
inline ::google::protobuf::int32 SystemConfProto::coordinator() const {
  return coordinator_;
}
inline void SystemConfProto::set_coordinator(::google::protobuf::int32 value) {
  set_has_coordinator();
  coordinator_ = value;
}

// required int32 worker_start = 2;
inline bool SystemConfProto::has_worker_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemConfProto::set_has_worker_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemConfProto::clear_has_worker_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemConfProto::clear_worker_start() {
  worker_start_ = 0;
  clear_has_worker_start();
}
inline ::google::protobuf::int32 SystemConfProto::worker_start() const {
  return worker_start_;
}
inline void SystemConfProto::set_worker_start(::google::protobuf::int32 value) {
  set_has_worker_start();
  worker_start_ = value;
}

// required int32 worker_end = 3;
inline bool SystemConfProto::has_worker_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemConfProto::set_has_worker_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemConfProto::clear_has_worker_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemConfProto::clear_worker_end() {
  worker_end_ = 0;
  clear_has_worker_end();
}
inline ::google::protobuf::int32 SystemConfProto::worker_end() const {
  return worker_end_;
}
inline void SystemConfProto::set_worker_end(::google::protobuf::int32 value) {
  set_has_worker_end();
  worker_end_ = value;
}

// optional int32 memory_start = 4;
inline bool SystemConfProto::has_memory_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SystemConfProto::set_has_memory_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SystemConfProto::clear_has_memory_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SystemConfProto::clear_memory_start() {
  memory_start_ = 0;
  clear_has_memory_start();
}
inline ::google::protobuf::int32 SystemConfProto::memory_start() const {
  return memory_start_;
}
inline void SystemConfProto::set_memory_start(::google::protobuf::int32 value) {
  set_has_memory_start();
  memory_start_ = value;
}

// optional int32 memory_end = 5;
inline bool SystemConfProto::has_memory_end() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SystemConfProto::set_has_memory_end() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SystemConfProto::clear_has_memory_end() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SystemConfProto::clear_memory_end() {
  memory_end_ = 0;
  clear_has_memory_end();
}
inline ::google::protobuf::int32 SystemConfProto::memory_end() const {
  return memory_end_;
}
inline void SystemConfProto::set_memory_end(::google::protobuf::int32 value) {
  set_has_memory_end();
  memory_end_ = value;
}

// optional int32 disk_start = 6;
inline bool SystemConfProto::has_disk_start() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SystemConfProto::set_has_disk_start() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SystemConfProto::clear_has_disk_start() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SystemConfProto::clear_disk_start() {
  disk_start_ = 0;
  clear_has_disk_start();
}
inline ::google::protobuf::int32 SystemConfProto::disk_start() const {
  return disk_start_;
}
inline void SystemConfProto::set_disk_start(::google::protobuf::int32 value) {
  set_has_disk_start();
  disk_start_ = value;
}

// optional int32 disk_end = 7;
inline bool SystemConfProto::has_disk_end() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SystemConfProto::set_has_disk_end() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SystemConfProto::clear_has_disk_end() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SystemConfProto::clear_disk_end() {
  disk_end_ = 0;
  clear_has_disk_end();
}
inline ::google::protobuf::int32 SystemConfProto::disk_end() const {
  return disk_end_;
}
inline void SystemConfProto::set_disk_end(::google::protobuf::int32 value) {
  set_has_disk_end();
  disk_end_ = value;
}

// -------------------------------------------------------------------

// DataSourceProto

// required string name = 1;
inline bool DataSourceProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataSourceProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataSourceProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataSourceProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DataSourceProto::name() const {
  return *name_;
}
inline void DataSourceProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DataSourceProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DataSourceProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataSourceProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DataSourceProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataSourceProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string parser = 2;
inline bool DataSourceProto::has_parser() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataSourceProto::set_has_parser() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataSourceProto::clear_has_parser() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataSourceProto::clear_parser() {
  if (parser_ != &::google::protobuf::internal::kEmptyString) {
    parser_->clear();
  }
  clear_has_parser();
}
inline const ::std::string& DataSourceProto::parser() const {
  return *parser_;
}
inline void DataSourceProto::set_parser(const ::std::string& value) {
  set_has_parser();
  if (parser_ == &::google::protobuf::internal::kEmptyString) {
    parser_ = new ::std::string;
  }
  parser_->assign(value);
}
inline void DataSourceProto::set_parser(const char* value) {
  set_has_parser();
  if (parser_ == &::google::protobuf::internal::kEmptyString) {
    parser_ = new ::std::string;
  }
  parser_->assign(value);
}
inline void DataSourceProto::set_parser(const char* value, size_t size) {
  set_has_parser();
  if (parser_ == &::google::protobuf::internal::kEmptyString) {
    parser_ = new ::std::string;
  }
  parser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataSourceProto::mutable_parser() {
  set_has_parser();
  if (parser_ == &::google::protobuf::internal::kEmptyString) {
    parser_ = new ::std::string;
  }
  return parser_;
}
inline ::std::string* DataSourceProto::release_parser() {
  clear_has_parser();
  if (parser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parser_;
    parser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataSourceProto::set_allocated_parser(::std::string* parser) {
  if (parser_ != &::google::protobuf::internal::kEmptyString) {
    delete parser_;
  }
  if (parser) {
    set_has_parser();
    parser_ = parser;
  } else {
    clear_has_parser();
    parser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 3;
inline bool DataSourceProto::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataSourceProto::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataSourceProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataSourceProto::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& DataSourceProto::path() const {
  return *path_;
}
inline void DataSourceProto::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void DataSourceProto::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void DataSourceProto::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataSourceProto::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* DataSourceProto::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataSourceProto::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 size = 4;
inline bool DataSourceProto::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataSourceProto::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataSourceProto::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataSourceProto::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 DataSourceProto::size() const {
  return size_;
}
inline void DataSourceProto::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// optional int64 num = 5;
inline bool DataSourceProto::has_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataSourceProto::set_has_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataSourceProto::clear_has_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataSourceProto::clear_num() {
  num_ = GOOGLE_LONGLONG(0);
  clear_has_num();
}
inline ::google::protobuf::int64 DataSourceProto::num() const {
  return num_;
}
inline void DataSourceProto::set_num(::google::protobuf::int64 value) {
  set_has_num();
  num_ = value;
}

// optional .lapis.DataSourceProto.DataType type = 6;
inline bool DataSourceProto::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataSourceProto::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataSourceProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataSourceProto::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::lapis::DataSourceProto_DataType DataSourceProto::type() const {
  return static_cast< ::lapis::DataSourceProto_DataType >(type_);
}
inline void DataSourceProto::set_type(::lapis::DataSourceProto_DataType value) {
  assert(::lapis::DataSourceProto_DataType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 channels = 7;
inline bool DataSourceProto::has_channels() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataSourceProto::set_has_channels() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataSourceProto::clear_has_channels() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataSourceProto::clear_channels() {
  channels_ = 0;
  clear_has_channels();
}
inline ::google::protobuf::int32 DataSourceProto::channels() const {
  return channels_;
}
inline void DataSourceProto::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
}

// optional int32 height = 8;
inline bool DataSourceProto::has_height() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataSourceProto::set_has_height() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataSourceProto::clear_has_height() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataSourceProto::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 DataSourceProto::height() const {
  return height_;
}
inline void DataSourceProto::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 width = 9;
inline bool DataSourceProto::has_width() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataSourceProto::set_has_width() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataSourceProto::clear_has_width() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataSourceProto::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 DataSourceProto::width() const {
  return width_;
}
inline void DataSourceProto::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// -------------------------------------------------------------------

// RGBDatum

// optional int32 channels = 1 [default = 3];
inline bool RGBDatum::has_channels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RGBDatum::set_has_channels() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RGBDatum::clear_has_channels() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RGBDatum::clear_channels() {
  channels_ = 3;
  clear_has_channels();
}
inline ::google::protobuf::int32 RGBDatum::channels() const {
  return channels_;
}
inline void RGBDatum::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
}

// optional int32 height = 2 [default = 0];
inline bool RGBDatum::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RGBDatum::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RGBDatum::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RGBDatum::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 RGBDatum::height() const {
  return height_;
}
inline void RGBDatum::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 width = 3 [default = 0];
inline bool RGBDatum::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RGBDatum::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RGBDatum::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RGBDatum::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 RGBDatum::width() const {
  return width_;
}
inline void RGBDatum::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// required string content = 4;
inline bool RGBDatum::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RGBDatum::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RGBDatum::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RGBDatum::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& RGBDatum::content() const {
  return *content_;
}
inline void RGBDatum::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void RGBDatum::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void RGBDatum::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RGBDatum::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* RGBDatum::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RGBDatum::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ParamProto

// required string name = 1;
inline bool ParamProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParamProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParamProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParamProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ParamProto::name() const {
  return *name_;
}
inline void ParamProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ParamProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ParamProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParamProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ParamProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParamProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string initializer = 2 [default = "Zero"];
inline bool ParamProto::has_initializer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParamProto::set_has_initializer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParamProto::clear_has_initializer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParamProto::clear_initializer() {
  if (initializer_ != _default_initializer_) {
    initializer_->assign(*_default_initializer_);
  }
  clear_has_initializer();
}
inline const ::std::string& ParamProto::initializer() const {
  return *initializer_;
}
inline void ParamProto::set_initializer(const ::std::string& value) {
  set_has_initializer();
  if (initializer_ == _default_initializer_) {
    initializer_ = new ::std::string;
  }
  initializer_->assign(value);
}
inline void ParamProto::set_initializer(const char* value) {
  set_has_initializer();
  if (initializer_ == _default_initializer_) {
    initializer_ = new ::std::string;
  }
  initializer_->assign(value);
}
inline void ParamProto::set_initializer(const char* value, size_t size) {
  set_has_initializer();
  if (initializer_ == _default_initializer_) {
    initializer_ = new ::std::string;
  }
  initializer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParamProto::mutable_initializer() {
  set_has_initializer();
  if (initializer_ == _default_initializer_) {
    initializer_ = new ::std::string(*_default_initializer_);
  }
  return initializer_;
}
inline ::std::string* ParamProto::release_initializer() {
  clear_has_initializer();
  if (initializer_ == _default_initializer_) {
    return NULL;
  } else {
    ::std::string* temp = initializer_;
    initializer_ = const_cast< ::std::string*>(_default_initializer_);
    return temp;
  }
}
inline void ParamProto::set_allocated_initializer(::std::string* initializer) {
  if (initializer_ != _default_initializer_) {
    delete initializer_;
  }
  if (initializer) {
    set_has_initializer();
    initializer_ = initializer;
  } else {
    clear_has_initializer();
    initializer_ = const_cast< ::std::string*>(_default_initializer_);
  }
}

// repeated int32 shape = 3;
inline int ParamProto::shape_size() const {
  return shape_.size();
}
inline void ParamProto::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int32 ParamProto::shape(int index) const {
  return shape_.Get(index);
}
inline void ParamProto::set_shape(int index, ::google::protobuf::int32 value) {
  shape_.Set(index, value);
}
inline void ParamProto::add_shape(::google::protobuf::int32 value) {
  shape_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ParamProto::shape() const {
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ParamProto::mutable_shape() {
  return &shape_;
}

// optional string partitioner = 4;
inline bool ParamProto::has_partitioner() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParamProto::set_has_partitioner() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParamProto::clear_has_partitioner() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParamProto::clear_partitioner() {
  if (partitioner_ != &::google::protobuf::internal::kEmptyString) {
    partitioner_->clear();
  }
  clear_has_partitioner();
}
inline const ::std::string& ParamProto::partitioner() const {
  return *partitioner_;
}
inline void ParamProto::set_partitioner(const ::std::string& value) {
  set_has_partitioner();
  if (partitioner_ == &::google::protobuf::internal::kEmptyString) {
    partitioner_ = new ::std::string;
  }
  partitioner_->assign(value);
}
inline void ParamProto::set_partitioner(const char* value) {
  set_has_partitioner();
  if (partitioner_ == &::google::protobuf::internal::kEmptyString) {
    partitioner_ = new ::std::string;
  }
  partitioner_->assign(value);
}
inline void ParamProto::set_partitioner(const char* value, size_t size) {
  set_has_partitioner();
  if (partitioner_ == &::google::protobuf::internal::kEmptyString) {
    partitioner_ = new ::std::string;
  }
  partitioner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParamProto::mutable_partitioner() {
  set_has_partitioner();
  if (partitioner_ == &::google::protobuf::internal::kEmptyString) {
    partitioner_ = new ::std::string;
  }
  return partitioner_;
}
inline ::std::string* ParamProto::release_partitioner() {
  clear_has_partitioner();
  if (partitioner_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = partitioner_;
    partitioner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParamProto::set_allocated_partitioner(::std::string* partitioner) {
  if (partitioner_ != &::google::protobuf::internal::kEmptyString) {
    delete partitioner_;
  }
  if (partitioner) {
    set_has_partitioner();
    partitioner_ = partitioner;
  } else {
    clear_has_partitioner();
    partitioner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated float content = 5 [packed = true];
inline int ParamProto::content_size() const {
  return content_.size();
}
inline void ParamProto::clear_content() {
  content_.Clear();
}
inline float ParamProto::content(int index) const {
  return content_.Get(index);
}
inline void ParamProto::set_content(int index, float value) {
  content_.Set(index, value);
}
inline void ParamProto::add_content(float value) {
  content_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ParamProto::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedField< float >*
ParamProto::mutable_content() {
  return &content_;
}

// -------------------------------------------------------------------

// EdgeProto

// required string name = 1;
inline bool EdgeProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EdgeProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EdgeProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EdgeProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EdgeProto::name() const {
  return *name_;
}
inline void EdgeProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void EdgeProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void EdgeProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EdgeProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* EdgeProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EdgeProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string type = 2;
inline bool EdgeProto::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EdgeProto::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EdgeProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EdgeProto::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& EdgeProto::type() const {
  return *type_;
}
inline void EdgeProto::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void EdgeProto::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void EdgeProto::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EdgeProto::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* EdgeProto::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EdgeProto::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .lapis.ParamProto param = 3;
inline int EdgeProto::param_size() const {
  return param_.size();
}
inline void EdgeProto::clear_param() {
  param_.Clear();
}
inline const ::lapis::ParamProto& EdgeProto::param(int index) const {
  return param_.Get(index);
}
inline ::lapis::ParamProto* EdgeProto::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::lapis::ParamProto* EdgeProto::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto >&
EdgeProto::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto >*
EdgeProto::mutable_param() {
  return &param_;
}

// optional bool directed = 4 [default = true];
inline bool EdgeProto::has_directed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EdgeProto::set_has_directed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EdgeProto::clear_has_directed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EdgeProto::clear_directed() {
  directed_ = true;
  clear_has_directed();
}
inline bool EdgeProto::directed() const {
  return directed_;
}
inline void EdgeProto::set_directed(bool value) {
  set_has_directed();
  directed_ = value;
}

// -------------------------------------------------------------------

// LayerProto

// required string name = 1;
inline bool LayerProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LayerProto::name() const {
  return *name_;
}
inline void LayerProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LayerProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LayerProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LayerProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 num_output = 2;
inline bool LayerProto::has_num_output() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerProto::set_has_num_output() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerProto::clear_has_num_output() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerProto::clear_num_output() {
  num_output_ = 0;
  clear_has_num_output();
}
inline ::google::protobuf::int32 LayerProto::num_output() const {
  return num_output_;
}
inline void LayerProto::set_num_output(::google::protobuf::int32 value) {
  set_has_num_output();
  num_output_ = value;
}

// required string type = 3;
inline bool LayerProto::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerProto::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayerProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayerProto::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& LayerProto::type() const {
  return *type_;
}
inline void LayerProto::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void LayerProto::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void LayerProto::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerProto::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* LayerProto::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerProto::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .lapis.ParamProto param = 4;
inline int LayerProto::param_size() const {
  return param_.size();
}
inline void LayerProto::clear_param() {
  param_.Clear();
}
inline const ::lapis::ParamProto& LayerProto::param(int index) const {
  return param_.Get(index);
}
inline ::lapis::ParamProto* LayerProto::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::lapis::ParamProto* LayerProto::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto >&
LayerProto::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto >*
LayerProto::mutable_param() {
  return &param_;
}

// repeated string out_edge = 5;
inline int LayerProto::out_edge_size() const {
  return out_edge_.size();
}
inline void LayerProto::clear_out_edge() {
  out_edge_.Clear();
}
inline const ::std::string& LayerProto::out_edge(int index) const {
  return out_edge_.Get(index);
}
inline ::std::string* LayerProto::mutable_out_edge(int index) {
  return out_edge_.Mutable(index);
}
inline void LayerProto::set_out_edge(int index, const ::std::string& value) {
  out_edge_.Mutable(index)->assign(value);
}
inline void LayerProto::set_out_edge(int index, const char* value) {
  out_edge_.Mutable(index)->assign(value);
}
inline void LayerProto::set_out_edge(int index, const char* value, size_t size) {
  out_edge_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerProto::add_out_edge() {
  return out_edge_.Add();
}
inline void LayerProto::add_out_edge(const ::std::string& value) {
  out_edge_.Add()->assign(value);
}
inline void LayerProto::add_out_edge(const char* value) {
  out_edge_.Add()->assign(value);
}
inline void LayerProto::add_out_edge(const char* value, size_t size) {
  out_edge_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LayerProto::out_edge() const {
  return out_edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LayerProto::mutable_out_edge() {
  return &out_edge_;
}

// repeated string in_edge = 6;
inline int LayerProto::in_edge_size() const {
  return in_edge_.size();
}
inline void LayerProto::clear_in_edge() {
  in_edge_.Clear();
}
inline const ::std::string& LayerProto::in_edge(int index) const {
  return in_edge_.Get(index);
}
inline ::std::string* LayerProto::mutable_in_edge(int index) {
  return in_edge_.Mutable(index);
}
inline void LayerProto::set_in_edge(int index, const ::std::string& value) {
  in_edge_.Mutable(index)->assign(value);
}
inline void LayerProto::set_in_edge(int index, const char* value) {
  in_edge_.Mutable(index)->assign(value);
}
inline void LayerProto::set_in_edge(int index, const char* value, size_t size) {
  in_edge_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerProto::add_in_edge() {
  return in_edge_.Add();
}
inline void LayerProto::add_in_edge(const ::std::string& value) {
  in_edge_.Add()->assign(value);
}
inline void LayerProto::add_in_edge(const char* value) {
  in_edge_.Add()->assign(value);
}
inline void LayerProto::add_in_edge(const char* value, size_t size) {
  in_edge_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LayerProto::in_edge() const {
  return in_edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LayerProto::mutable_in_edge() {
  return &in_edge_;
}

// -------------------------------------------------------------------

// NetProto

// repeated .lapis.LayerProto layer = 3;
inline int NetProto::layer_size() const {
  return layer_.size();
}
inline void NetProto::clear_layer() {
  layer_.Clear();
}
inline const ::lapis::LayerProto& NetProto::layer(int index) const {
  return layer_.Get(index);
}
inline ::lapis::LayerProto* NetProto::mutable_layer(int index) {
  return layer_.Mutable(index);
}
inline ::lapis::LayerProto* NetProto::add_layer() {
  return layer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::LayerProto >&
NetProto::layer() const {
  return layer_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::LayerProto >*
NetProto::mutable_layer() {
  return &layer_;
}

// repeated .lapis.EdgeProto edge = 4;
inline int NetProto::edge_size() const {
  return edge_.size();
}
inline void NetProto::clear_edge() {
  edge_.Clear();
}
inline const ::lapis::EdgeProto& NetProto::edge(int index) const {
  return edge_.Get(index);
}
inline ::lapis::EdgeProto* NetProto::mutable_edge(int index) {
  return edge_.Mutable(index);
}
inline ::lapis::EdgeProto* NetProto::add_edge() {
  return edge_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::EdgeProto >&
NetProto::edge() const {
  return edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::EdgeProto >*
NetProto::mutable_edge() {
  return &edge_;
}

// -------------------------------------------------------------------

// SGDProto

// required float base_learning_rate = 1;
inline bool SGDProto::has_base_learning_rate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SGDProto::set_has_base_learning_rate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SGDProto::clear_has_base_learning_rate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SGDProto::clear_base_learning_rate() {
  base_learning_rate_ = 0;
  clear_has_base_learning_rate();
}
inline float SGDProto::base_learning_rate() const {
  return base_learning_rate_;
}
inline void SGDProto::set_base_learning_rate(float value) {
  set_has_base_learning_rate();
  base_learning_rate_ = value;
}

// optional float base_momentum = 2 [default = 0];
inline bool SGDProto::has_base_momentum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SGDProto::set_has_base_momentum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SGDProto::clear_has_base_momentum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SGDProto::clear_base_momentum() {
  base_momentum_ = 0;
  clear_has_base_momentum();
}
inline float SGDProto::base_momentum() const {
  return base_momentum_;
}
inline void SGDProto::set_base_momentum(float value) {
  set_has_base_momentum();
  base_momentum_ = value;
}

// optional float base_weight_decay = 3 [default = 0];
inline bool SGDProto::has_base_weight_decay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SGDProto::set_has_base_weight_decay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SGDProto::clear_has_base_weight_decay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SGDProto::clear_base_weight_decay() {
  base_weight_decay_ = 0;
  clear_has_base_weight_decay();
}
inline float SGDProto::base_weight_decay() const {
  return base_weight_decay_;
}
inline void SGDProto::set_base_weight_decay(float value) {
  set_has_base_weight_decay();
  base_weight_decay_ = value;
}

// optional float final_momentum = 4;
inline bool SGDProto::has_final_momentum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SGDProto::set_has_final_momentum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SGDProto::clear_has_final_momentum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SGDProto::clear_final_momentum() {
  final_momentum_ = 0;
  clear_has_final_momentum();
}
inline float SGDProto::final_momentum() const {
  return final_momentum_;
}
inline void SGDProto::set_final_momentum(float value) {
  set_has_final_momentum();
  final_momentum_ = value;
}

// optional float final_learning_rate = 5;
inline bool SGDProto::has_final_learning_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SGDProto::set_has_final_learning_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SGDProto::clear_has_final_learning_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SGDProto::clear_final_learning_rate() {
  final_learning_rate_ = 0;
  clear_has_final_learning_rate();
}
inline float SGDProto::final_learning_rate() const {
  return final_learning_rate_;
}
inline void SGDProto::set_final_learning_rate(float value) {
  set_has_final_learning_rate();
  final_learning_rate_ = value;
}

// optional float final_weight_decay = 6;
inline bool SGDProto::has_final_weight_decay() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SGDProto::set_has_final_weight_decay() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SGDProto::clear_has_final_weight_decay() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SGDProto::clear_final_weight_decay() {
  final_weight_decay_ = 0;
  clear_has_final_weight_decay();
}
inline float SGDProto::final_weight_decay() const {
  return final_weight_decay_;
}
inline void SGDProto::set_final_weight_decay(float value) {
  set_has_final_weight_decay();
  final_weight_decay_ = value;
}

// optional int32 learning_rate_change_steps = 7;
inline bool SGDProto::has_learning_rate_change_steps() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SGDProto::set_has_learning_rate_change_steps() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SGDProto::clear_has_learning_rate_change_steps() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SGDProto::clear_learning_rate_change_steps() {
  learning_rate_change_steps_ = 0;
  clear_has_learning_rate_change_steps();
}
inline ::google::protobuf::int32 SGDProto::learning_rate_change_steps() const {
  return learning_rate_change_steps_;
}
inline void SGDProto::set_learning_rate_change_steps(::google::protobuf::int32 value) {
  set_has_learning_rate_change_steps();
  learning_rate_change_steps_ = value;
}

// optional int32 momentum_change_steps = 8;
inline bool SGDProto::has_momentum_change_steps() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SGDProto::set_has_momentum_change_steps() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SGDProto::clear_has_momentum_change_steps() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SGDProto::clear_momentum_change_steps() {
  momentum_change_steps_ = 0;
  clear_has_momentum_change_steps();
}
inline ::google::protobuf::int32 SGDProto::momentum_change_steps() const {
  return momentum_change_steps_;
}
inline void SGDProto::set_momentum_change_steps(::google::protobuf::int32 value) {
  set_has_momentum_change_steps();
  momentum_change_steps_ = value;
}

// optional int32 weight_decay_change_steps = 9;
inline bool SGDProto::has_weight_decay_change_steps() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SGDProto::set_has_weight_decay_change_steps() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SGDProto::clear_has_weight_decay_change_steps() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SGDProto::clear_weight_decay_change_steps() {
  weight_decay_change_steps_ = 0;
  clear_has_weight_decay_change_steps();
}
inline ::google::protobuf::int32 SGDProto::weight_decay_change_steps() const {
  return weight_decay_change_steps_;
}
inline void SGDProto::set_weight_decay_change_steps(::google::protobuf::int32 value) {
  set_has_weight_decay_change_steps();
  weight_decay_change_steps_ = value;
}

// optional .lapis.SGDProto.ChangeProto learning_rate_change = 10 [default = INVERSE_T];
inline bool SGDProto::has_learning_rate_change() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SGDProto::set_has_learning_rate_change() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SGDProto::clear_has_learning_rate_change() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SGDProto::clear_learning_rate_change() {
  learning_rate_change_ = 1;
  clear_has_learning_rate_change();
}
inline ::lapis::SGDProto_ChangeProto SGDProto::learning_rate_change() const {
  return static_cast< ::lapis::SGDProto_ChangeProto >(learning_rate_change_);
}
inline void SGDProto::set_learning_rate_change(::lapis::SGDProto_ChangeProto value) {
  assert(::lapis::SGDProto_ChangeProto_IsValid(value));
  set_has_learning_rate_change();
  learning_rate_change_ = value;
}

// optional .lapis.SGDProto.ChangeProto weight_decay_change = 11 [default = FIXED];
inline bool SGDProto::has_weight_decay_change() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SGDProto::set_has_weight_decay_change() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SGDProto::clear_has_weight_decay_change() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SGDProto::clear_weight_decay_change() {
  weight_decay_change_ = 0;
  clear_has_weight_decay_change();
}
inline ::lapis::SGDProto_ChangeProto SGDProto::weight_decay_change() const {
  return static_cast< ::lapis::SGDProto_ChangeProto >(weight_decay_change_);
}
inline void SGDProto::set_weight_decay_change(::lapis::SGDProto_ChangeProto value) {
  assert(::lapis::SGDProto_ChangeProto_IsValid(value));
  set_has_weight_decay_change();
  weight_decay_change_ = value;
}

// optional .lapis.SGDProto.ChangeProto momentum_change = 12 [default = FIXED];
inline bool SGDProto::has_momentum_change() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SGDProto::set_has_momentum_change() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SGDProto::clear_has_momentum_change() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SGDProto::clear_momentum_change() {
  momentum_change_ = 0;
  clear_has_momentum_change();
}
inline ::lapis::SGDProto_ChangeProto SGDProto::momentum_change() const {
  return static_cast< ::lapis::SGDProto_ChangeProto >(momentum_change_);
}
inline void SGDProto::set_momentum_change(::lapis::SGDProto_ChangeProto value) {
  assert(::lapis::SGDProto_ChangeProto_IsValid(value));
  set_has_momentum_change();
  momentum_change_ = value;
}

// optional int32 total_steps = 13;
inline bool SGDProto::has_total_steps() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SGDProto::set_has_total_steps() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SGDProto::clear_has_total_steps() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SGDProto::clear_total_steps() {
  total_steps_ = 0;
  clear_has_total_steps();
}
inline ::google::protobuf::int32 SGDProto::total_steps() const {
  return total_steps_;
}
inline void SGDProto::set_total_steps(::google::protobuf::int32 value) {
  set_has_total_steps();
  total_steps_ = value;
}

// optional int32 batchsize = 14;
inline bool SGDProto::has_batchsize() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SGDProto::set_has_batchsize() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SGDProto::clear_has_batchsize() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SGDProto::clear_batchsize() {
  batchsize_ = 0;
  clear_has_batchsize();
}
inline ::google::protobuf::int32 SGDProto::batchsize() const {
  return batchsize_;
}
inline void SGDProto::set_batchsize(::google::protobuf::int32 value) {
  set_has_batchsize();
  batchsize_ = value;
}

// -------------------------------------------------------------------

// PerformanceProto

// optional float precision = 1;
inline bool PerformanceProto::has_precision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerformanceProto::set_has_precision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerformanceProto::clear_has_precision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerformanceProto::clear_precision() {
  precision_ = 0;
  clear_has_precision();
}
inline float PerformanceProto::precision() const {
  return precision_;
}
inline void PerformanceProto::set_precision(float value) {
  set_has_precision();
  precision_ = value;
}

// optional float recall = 2;
inline bool PerformanceProto::has_recall() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerformanceProto::set_has_recall() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerformanceProto::clear_has_recall() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerformanceProto::clear_recall() {
  recall_ = 0;
  clear_has_recall();
}
inline float PerformanceProto::recall() const {
  return recall_;
}
inline void PerformanceProto::set_recall(float value) {
  set_has_recall();
  recall_ = value;
}

// optional float map = 3;
inline bool PerformanceProto::has_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerformanceProto::set_has_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerformanceProto::clear_has_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PerformanceProto::clear_map() {
  map_ = 0;
  clear_has_map();
}
inline float PerformanceProto::map() const {
  return map_;
}
inline void PerformanceProto::set_map(float value) {
  set_has_map();
  map_ = value;
}

// optional float precision50 = 4;
inline bool PerformanceProto::has_precision50() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerformanceProto::set_has_precision50() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerformanceProto::clear_has_precision50() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PerformanceProto::clear_precision50() {
  precision50_ = 0;
  clear_has_precision50();
}
inline float PerformanceProto::precision50() const {
  return precision50_;
}
inline void PerformanceProto::set_precision50(float value) {
  set_has_precision50();
  precision50_ = value;
}

// -------------------------------------------------------------------

// TrainerProto

// optional .lapis.SGDProto sgd = 1;
inline bool TrainerProto::has_sgd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrainerProto::set_has_sgd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrainerProto::clear_has_sgd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrainerProto::clear_sgd() {
  if (sgd_ != NULL) sgd_->::lapis::SGDProto::Clear();
  clear_has_sgd();
}
inline const ::lapis::SGDProto& TrainerProto::sgd() const {
  return sgd_ != NULL ? *sgd_ : *default_instance_->sgd_;
}
inline ::lapis::SGDProto* TrainerProto::mutable_sgd() {
  set_has_sgd();
  if (sgd_ == NULL) sgd_ = new ::lapis::SGDProto;
  return sgd_;
}
inline ::lapis::SGDProto* TrainerProto::release_sgd() {
  clear_has_sgd();
  ::lapis::SGDProto* temp = sgd_;
  sgd_ = NULL;
  return temp;
}
inline void TrainerProto::set_allocated_sgd(::lapis::SGDProto* sgd) {
  delete sgd_;
  sgd_ = sgd;
  if (sgd) {
    set_has_sgd();
  } else {
    clear_has_sgd();
  }
}

// optional int32 checkpoint_after_steps = 2 [default = 0];
inline bool TrainerProto::has_checkpoint_after_steps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrainerProto::set_has_checkpoint_after_steps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrainerProto::clear_has_checkpoint_after_steps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrainerProto::clear_checkpoint_after_steps() {
  checkpoint_after_steps_ = 0;
  clear_has_checkpoint_after_steps();
}
inline ::google::protobuf::int32 TrainerProto::checkpoint_after_steps() const {
  return checkpoint_after_steps_;
}
inline void TrainerProto::set_checkpoint_after_steps(::google::protobuf::int32 value) {
  set_has_checkpoint_after_steps();
  checkpoint_after_steps_ = value;
}

// optional int32 checkpoint_every_steps = 3 [default = 0];
inline bool TrainerProto::has_checkpoint_every_steps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrainerProto::set_has_checkpoint_every_steps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrainerProto::clear_has_checkpoint_every_steps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrainerProto::clear_checkpoint_every_steps() {
  checkpoint_every_steps_ = 0;
  clear_has_checkpoint_every_steps();
}
inline ::google::protobuf::int32 TrainerProto::checkpoint_every_steps() const {
  return checkpoint_every_steps_;
}
inline void TrainerProto::set_checkpoint_every_steps(::google::protobuf::int32 value) {
  set_has_checkpoint_every_steps();
  checkpoint_every_steps_ = value;
}

// optional string checkpoint_prefix = 4 [default = "tmp/checkpoint"];
inline bool TrainerProto::has_checkpoint_prefix() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrainerProto::set_has_checkpoint_prefix() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrainerProto::clear_has_checkpoint_prefix() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrainerProto::clear_checkpoint_prefix() {
  if (checkpoint_prefix_ != _default_checkpoint_prefix_) {
    checkpoint_prefix_->assign(*_default_checkpoint_prefix_);
  }
  clear_has_checkpoint_prefix();
}
inline const ::std::string& TrainerProto::checkpoint_prefix() const {
  return *checkpoint_prefix_;
}
inline void TrainerProto::set_checkpoint_prefix(const ::std::string& value) {
  set_has_checkpoint_prefix();
  if (checkpoint_prefix_ == _default_checkpoint_prefix_) {
    checkpoint_prefix_ = new ::std::string;
  }
  checkpoint_prefix_->assign(value);
}
inline void TrainerProto::set_checkpoint_prefix(const char* value) {
  set_has_checkpoint_prefix();
  if (checkpoint_prefix_ == _default_checkpoint_prefix_) {
    checkpoint_prefix_ = new ::std::string;
  }
  checkpoint_prefix_->assign(value);
}
inline void TrainerProto::set_checkpoint_prefix(const char* value, size_t size) {
  set_has_checkpoint_prefix();
  if (checkpoint_prefix_ == _default_checkpoint_prefix_) {
    checkpoint_prefix_ = new ::std::string;
  }
  checkpoint_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrainerProto::mutable_checkpoint_prefix() {
  set_has_checkpoint_prefix();
  if (checkpoint_prefix_ == _default_checkpoint_prefix_) {
    checkpoint_prefix_ = new ::std::string(*_default_checkpoint_prefix_);
  }
  return checkpoint_prefix_;
}
inline ::std::string* TrainerProto::release_checkpoint_prefix() {
  clear_has_checkpoint_prefix();
  if (checkpoint_prefix_ == _default_checkpoint_prefix_) {
    return NULL;
  } else {
    ::std::string* temp = checkpoint_prefix_;
    checkpoint_prefix_ = const_cast< ::std::string*>(_default_checkpoint_prefix_);
    return temp;
  }
}
inline void TrainerProto::set_allocated_checkpoint_prefix(::std::string* checkpoint_prefix) {
  if (checkpoint_prefix_ != _default_checkpoint_prefix_) {
    delete checkpoint_prefix_;
  }
  if (checkpoint_prefix) {
    set_has_checkpoint_prefix();
    checkpoint_prefix_ = checkpoint_prefix;
  } else {
    clear_has_checkpoint_prefix();
    checkpoint_prefix_ = const_cast< ::std::string*>(_default_checkpoint_prefix_);
  }
}

// optional int32 checkpoint_step = 5 [default = 0];
inline bool TrainerProto::has_checkpoint_step() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrainerProto::set_has_checkpoint_step() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrainerProto::clear_has_checkpoint_step() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrainerProto::clear_checkpoint_step() {
  checkpoint_step_ = 0;
  clear_has_checkpoint_step();
}
inline ::google::protobuf::int32 TrainerProto::checkpoint_step() const {
  return checkpoint_step_;
}
inline void TrainerProto::set_checkpoint_step(::google::protobuf::int32 value) {
  set_has_checkpoint_step();
  checkpoint_step_ = value;
}

// optional int32 display_after_steps = 6 [default = 0];
inline bool TrainerProto::has_display_after_steps() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrainerProto::set_has_display_after_steps() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrainerProto::clear_has_display_after_steps() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrainerProto::clear_display_after_steps() {
  display_after_steps_ = 0;
  clear_has_display_after_steps();
}
inline ::google::protobuf::int32 TrainerProto::display_after_steps() const {
  return display_after_steps_;
}
inline void TrainerProto::set_display_after_steps(::google::protobuf::int32 value) {
  set_has_display_after_steps();
  display_after_steps_ = value;
}

// optional int32 display_every_steps = 7 [default = 0];
inline bool TrainerProto::has_display_every_steps() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrainerProto::set_has_display_every_steps() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrainerProto::clear_has_display_every_steps() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrainerProto::clear_display_every_steps() {
  display_every_steps_ = 0;
  clear_has_display_every_steps();
}
inline ::google::protobuf::int32 TrainerProto::display_every_steps() const {
  return display_every_steps_;
}
inline void TrainerProto::set_display_every_steps(::google::protobuf::int32 value) {
  set_has_display_every_steps();
  display_every_steps_ = value;
}

// optional string display_prefix = 8 [default = "tmp/display"];
inline bool TrainerProto::has_display_prefix() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrainerProto::set_has_display_prefix() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrainerProto::clear_has_display_prefix() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrainerProto::clear_display_prefix() {
  if (display_prefix_ != _default_display_prefix_) {
    display_prefix_->assign(*_default_display_prefix_);
  }
  clear_has_display_prefix();
}
inline const ::std::string& TrainerProto::display_prefix() const {
  return *display_prefix_;
}
inline void TrainerProto::set_display_prefix(const ::std::string& value) {
  set_has_display_prefix();
  if (display_prefix_ == _default_display_prefix_) {
    display_prefix_ = new ::std::string;
  }
  display_prefix_->assign(value);
}
inline void TrainerProto::set_display_prefix(const char* value) {
  set_has_display_prefix();
  if (display_prefix_ == _default_display_prefix_) {
    display_prefix_ = new ::std::string;
  }
  display_prefix_->assign(value);
}
inline void TrainerProto::set_display_prefix(const char* value, size_t size) {
  set_has_display_prefix();
  if (display_prefix_ == _default_display_prefix_) {
    display_prefix_ = new ::std::string;
  }
  display_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrainerProto::mutable_display_prefix() {
  set_has_display_prefix();
  if (display_prefix_ == _default_display_prefix_) {
    display_prefix_ = new ::std::string(*_default_display_prefix_);
  }
  return display_prefix_;
}
inline ::std::string* TrainerProto::release_display_prefix() {
  clear_has_display_prefix();
  if (display_prefix_ == _default_display_prefix_) {
    return NULL;
  } else {
    ::std::string* temp = display_prefix_;
    display_prefix_ = const_cast< ::std::string*>(_default_display_prefix_);
    return temp;
  }
}
inline void TrainerProto::set_allocated_display_prefix(::std::string* display_prefix) {
  if (display_prefix_ != _default_display_prefix_) {
    delete display_prefix_;
  }
  if (display_prefix) {
    set_has_display_prefix();
    display_prefix_ = display_prefix;
  } else {
    clear_has_display_prefix();
    display_prefix_ = const_cast< ::std::string*>(_default_display_prefix_);
  }
}

// repeated .lapis.DataSourceProto train_data = 9;
inline int TrainerProto::train_data_size() const {
  return train_data_.size();
}
inline void TrainerProto::clear_train_data() {
  train_data_.Clear();
}
inline const ::lapis::DataSourceProto& TrainerProto::train_data(int index) const {
  return train_data_.Get(index);
}
inline ::lapis::DataSourceProto* TrainerProto::mutable_train_data(int index) {
  return train_data_.Mutable(index);
}
inline ::lapis::DataSourceProto* TrainerProto::add_train_data() {
  return train_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >&
TrainerProto::train_data() const {
  return train_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >*
TrainerProto::mutable_train_data() {
  return &train_data_;
}

// repeated .lapis.DataSourceProto validation_data = 10;
inline int TrainerProto::validation_data_size() const {
  return validation_data_.size();
}
inline void TrainerProto::clear_validation_data() {
  validation_data_.Clear();
}
inline const ::lapis::DataSourceProto& TrainerProto::validation_data(int index) const {
  return validation_data_.Get(index);
}
inline ::lapis::DataSourceProto* TrainerProto::mutable_validation_data(int index) {
  return validation_data_.Mutable(index);
}
inline ::lapis::DataSourceProto* TrainerProto::add_validation_data() {
  return validation_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >&
TrainerProto::validation_data() const {
  return validation_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >*
TrainerProto::mutable_validation_data() {
  return &validation_data_;
}

// repeated .lapis.DataSourceProto test_data = 11;
inline int TrainerProto::test_data_size() const {
  return test_data_.size();
}
inline void TrainerProto::clear_test_data() {
  test_data_.Clear();
}
inline const ::lapis::DataSourceProto& TrainerProto::test_data(int index) const {
  return test_data_.Get(index);
}
inline ::lapis::DataSourceProto* TrainerProto::mutable_test_data(int index) {
  return test_data_.Mutable(index);
}
inline ::lapis::DataSourceProto* TrainerProto::add_test_data() {
  return test_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >&
TrainerProto::test_data() const {
  return test_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >*
TrainerProto::mutable_test_data() {
  return &test_data_;
}

// optional string perf_prefix = 14 [default = "tmp/performance"];
inline bool TrainerProto::has_perf_prefix() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TrainerProto::set_has_perf_prefix() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TrainerProto::clear_has_perf_prefix() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TrainerProto::clear_perf_prefix() {
  if (perf_prefix_ != _default_perf_prefix_) {
    perf_prefix_->assign(*_default_perf_prefix_);
  }
  clear_has_perf_prefix();
}
inline const ::std::string& TrainerProto::perf_prefix() const {
  return *perf_prefix_;
}
inline void TrainerProto::set_perf_prefix(const ::std::string& value) {
  set_has_perf_prefix();
  if (perf_prefix_ == _default_perf_prefix_) {
    perf_prefix_ = new ::std::string;
  }
  perf_prefix_->assign(value);
}
inline void TrainerProto::set_perf_prefix(const char* value) {
  set_has_perf_prefix();
  if (perf_prefix_ == _default_perf_prefix_) {
    perf_prefix_ = new ::std::string;
  }
  perf_prefix_->assign(value);
}
inline void TrainerProto::set_perf_prefix(const char* value, size_t size) {
  set_has_perf_prefix();
  if (perf_prefix_ == _default_perf_prefix_) {
    perf_prefix_ = new ::std::string;
  }
  perf_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrainerProto::mutable_perf_prefix() {
  set_has_perf_prefix();
  if (perf_prefix_ == _default_perf_prefix_) {
    perf_prefix_ = new ::std::string(*_default_perf_prefix_);
  }
  return perf_prefix_;
}
inline ::std::string* TrainerProto::release_perf_prefix() {
  clear_has_perf_prefix();
  if (perf_prefix_ == _default_perf_prefix_) {
    return NULL;
  } else {
    ::std::string* temp = perf_prefix_;
    perf_prefix_ = const_cast< ::std::string*>(_default_perf_prefix_);
    return temp;
  }
}
inline void TrainerProto::set_allocated_perf_prefix(::std::string* perf_prefix) {
  if (perf_prefix_ != _default_perf_prefix_) {
    delete perf_prefix_;
  }
  if (perf_prefix) {
    set_has_perf_prefix();
    perf_prefix_ = perf_prefix;
  } else {
    clear_has_perf_prefix();
    perf_prefix_ = const_cast< ::std::string*>(_default_perf_prefix_);
  }
}

// -------------------------------------------------------------------

// ModelConfProto

// optional string name = 1;
inline bool ModelConfProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelConfProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelConfProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelConfProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModelConfProto::name() const {
  return *name_;
}
inline void ModelConfProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelConfProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelConfProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelConfProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModelConfProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModelConfProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .lapis.NetProto net = 2;
inline bool ModelConfProto::has_net() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelConfProto::set_has_net() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelConfProto::clear_has_net() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelConfProto::clear_net() {
  if (net_ != NULL) net_->::lapis::NetProto::Clear();
  clear_has_net();
}
inline const ::lapis::NetProto& ModelConfProto::net() const {
  return net_ != NULL ? *net_ : *default_instance_->net_;
}
inline ::lapis::NetProto* ModelConfProto::mutable_net() {
  set_has_net();
  if (net_ == NULL) net_ = new ::lapis::NetProto;
  return net_;
}
inline ::lapis::NetProto* ModelConfProto::release_net() {
  clear_has_net();
  ::lapis::NetProto* temp = net_;
  net_ = NULL;
  return temp;
}
inline void ModelConfProto::set_allocated_net(::lapis::NetProto* net) {
  delete net_;
  net_ = net;
  if (net) {
    set_has_net();
  } else {
    clear_has_net();
  }
}

// required .lapis.TrainerProto trainer = 3;
inline bool ModelConfProto::has_trainer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelConfProto::set_has_trainer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelConfProto::clear_has_trainer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelConfProto::clear_trainer() {
  if (trainer_ != NULL) trainer_->::lapis::TrainerProto::Clear();
  clear_has_trainer();
}
inline const ::lapis::TrainerProto& ModelConfProto::trainer() const {
  return trainer_ != NULL ? *trainer_ : *default_instance_->trainer_;
}
inline ::lapis::TrainerProto* ModelConfProto::mutable_trainer() {
  set_has_trainer();
  if (trainer_ == NULL) trainer_ = new ::lapis::TrainerProto;
  return trainer_;
}
inline ::lapis::TrainerProto* ModelConfProto::release_trainer() {
  clear_has_trainer();
  ::lapis::TrainerProto* temp = trainer_;
  trainer_ = NULL;
  return temp;
}
inline void ModelConfProto::set_allocated_trainer(::lapis::TrainerProto* trainer) {
  delete trainer_;
  trainer_ = trainer;
  if (trainer) {
    set_has_trainer();
  } else {
    clear_has_trainer();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace lapis

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lapis::DataSourceProto_DataType>() {
  return ::lapis::DataSourceProto_DataType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lapis::SGDProto_ChangeProto>() {
  return ::lapis::SGDProto_ChangeProto_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_lapis_2eproto__INCLUDED
