// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model.proto

#ifndef PROTOBUF_model_2eproto__INCLUDED
#define PROTOBUF_model_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace lapis {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_model_2eproto();
void protobuf_AssignDesc_model_2eproto();
void protobuf_ShutdownFile_model_2eproto();

class DataSourceProto;
class RGBDatum;
class ParamProto;
class EdgeProto;
class BlobProto;
class LayerProto;
class NetProto;
class SGDProto;
class PerformanceProto;
class TrainerProto;
class ModelProto;
class float_vector_message;

enum ParamProto_InitMethod {
  ParamProto_InitMethod_kConstant = 0,
  ParamProto_InitMethod_kGaussain = 1,
  ParamProto_InitMethod_kUniform = 2,
  ParamProto_InitMethod_kPretrained = 3,
  ParamProto_InitMethod_kGaussainSqrtFanIn = 4,
  ParamProto_InitMethod_kUniformSqrtFanIn = 5,
  ParamProto_InitMethod_kUniformSqrtFanInOut = 6
};
bool ParamProto_InitMethod_IsValid(int value);
const ParamProto_InitMethod ParamProto_InitMethod_InitMethod_MIN = ParamProto_InitMethod_kConstant;
const ParamProto_InitMethod ParamProto_InitMethod_InitMethod_MAX = ParamProto_InitMethod_kUniformSqrtFanInOut;
const int ParamProto_InitMethod_InitMethod_ARRAYSIZE = ParamProto_InitMethod_InitMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParamProto_InitMethod_descriptor();
inline const ::std::string& ParamProto_InitMethod_Name(ParamProto_InitMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParamProto_InitMethod_descriptor(), value);
}
inline bool ParamProto_InitMethod_Parse(
    const ::std::string& name, ParamProto_InitMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParamProto_InitMethod>(
    ParamProto_InitMethod_descriptor(), name, value);
}
enum EdgeProto_PoolingMethod {
  EdgeProto_PoolingMethod_kMaxPooling = 1,
  EdgeProto_PoolingMethod_kAvgPooling = 2
};
bool EdgeProto_PoolingMethod_IsValid(int value);
const EdgeProto_PoolingMethod EdgeProto_PoolingMethod_PoolingMethod_MIN = EdgeProto_PoolingMethod_kMaxPooling;
const EdgeProto_PoolingMethod EdgeProto_PoolingMethod_PoolingMethod_MAX = EdgeProto_PoolingMethod_kAvgPooling;
const int EdgeProto_PoolingMethod_PoolingMethod_ARRAYSIZE = EdgeProto_PoolingMethod_PoolingMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* EdgeProto_PoolingMethod_descriptor();
inline const ::std::string& EdgeProto_PoolingMethod_Name(EdgeProto_PoolingMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    EdgeProto_PoolingMethod_descriptor(), value);
}
inline bool EdgeProto_PoolingMethod_Parse(
    const ::std::string& name, EdgeProto_PoolingMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EdgeProto_PoolingMethod>(
    EdgeProto_PoolingMethod_descriptor(), name, value);
}
enum SGDProto_ChangeProto {
  SGDProto_ChangeProto_kFixed = 0,
  SGDProto_ChangeProto_kInverse_t = 1,
  SGDProto_ChangeProto_kExponential = 2,
  SGDProto_ChangeProto_kLinear = 3,
  SGDProto_ChangeProto_kStep = 4
};
bool SGDProto_ChangeProto_IsValid(int value);
const SGDProto_ChangeProto SGDProto_ChangeProto_ChangeProto_MIN = SGDProto_ChangeProto_kFixed;
const SGDProto_ChangeProto SGDProto_ChangeProto_ChangeProto_MAX = SGDProto_ChangeProto_kStep;
const int SGDProto_ChangeProto_ChangeProto_ARRAYSIZE = SGDProto_ChangeProto_ChangeProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* SGDProto_ChangeProto_descriptor();
inline const ::std::string& SGDProto_ChangeProto_Name(SGDProto_ChangeProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    SGDProto_ChangeProto_descriptor(), value);
}
inline bool SGDProto_ChangeProto_Parse(
    const ::std::string& name, SGDProto_ChangeProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SGDProto_ChangeProto>(
    SGDProto_ChangeProto_descriptor(), name, value);
}
enum TrainerProto_Algorithm {
  TrainerProto_Algorithm_kBackPropagation = 1,
  TrainerProto_Algorithm_kContrastiveDivergence = 2
};
bool TrainerProto_Algorithm_IsValid(int value);
const TrainerProto_Algorithm TrainerProto_Algorithm_Algorithm_MIN = TrainerProto_Algorithm_kBackPropagation;
const TrainerProto_Algorithm TrainerProto_Algorithm_Algorithm_MAX = TrainerProto_Algorithm_kContrastiveDivergence;
const int TrainerProto_Algorithm_Algorithm_ARRAYSIZE = TrainerProto_Algorithm_Algorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrainerProto_Algorithm_descriptor();
inline const ::std::string& TrainerProto_Algorithm_Name(TrainerProto_Algorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrainerProto_Algorithm_descriptor(), value);
}
inline bool TrainerProto_Algorithm_Parse(
    const ::std::string& name, TrainerProto_Algorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrainerProto_Algorithm>(
    TrainerProto_Algorithm_descriptor(), name, value);
}
// ===================================================================

class DataSourceProto : public ::google::protobuf::Message {
 public:
  DataSourceProto();
  virtual ~DataSourceProto();

  DataSourceProto(const DataSourceProto& from);

  inline DataSourceProto& operator=(const DataSourceProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataSourceProto& default_instance();

  void Swap(DataSourceProto* other);

  // implements Message ----------------------------------------------

  DataSourceProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataSourceProto& from);
  void MergeFrom(const DataSourceProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional int64 size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // optional int32 channels = 6 [default = 1];
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 6;
  inline ::google::protobuf::int32 channels() const;
  inline void set_channels(::google::protobuf::int32 value);

  // optional int32 height = 7 [default = 0];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 7;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 width = 8 [default = 0];
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 8;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int64 offset = 9 [default = 0];
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 9;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:lapis.DataSourceProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* id_;
  ::std::string* path_;
  ::google::protobuf::int64 size_;
  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int32 width_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_model_2eproto();
  friend void protobuf_AssignDesc_model_2eproto();
  friend void protobuf_ShutdownFile_model_2eproto();

  void InitAsDefaultInstance();
  static DataSourceProto* default_instance_;
};
// -------------------------------------------------------------------

class RGBDatum : public ::google::protobuf::Message {
 public:
  RGBDatum();
  virtual ~RGBDatum();

  RGBDatum(const RGBDatum& from);

  inline RGBDatum& operator=(const RGBDatum& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RGBDatum& default_instance();

  void Swap(RGBDatum* other);

  // implements Message ----------------------------------------------

  RGBDatum* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RGBDatum& from);
  void MergeFrom(const RGBDatum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 channels = 1 [default = 3];
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 1;
  inline ::google::protobuf::int32 channels() const;
  inline void set_channels(::google::protobuf::int32 value);

  // optional int32 height = 2 [default = 0];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 width = 3 [default = 0];
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required string content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:lapis.RGBDatum)
 private:
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 channels_;
  ::google::protobuf::int32 height_;
  ::std::string* content_;
  ::google::protobuf::int32 width_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_model_2eproto();
  friend void protobuf_AssignDesc_model_2eproto();
  friend void protobuf_ShutdownFile_model_2eproto();

  void InitAsDefaultInstance();
  static RGBDatum* default_instance_;
};
// -------------------------------------------------------------------

class ParamProto : public ::google::protobuf::Message {
 public:
  ParamProto();
  virtual ~ParamProto();

  ParamProto(const ParamProto& from);

  inline ParamProto& operator=(const ParamProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParamProto& default_instance();

  void Swap(ParamProto* other);

  // implements Message ----------------------------------------------

  ParamProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParamProto& from);
  void MergeFrom(const ParamProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ParamProto_InitMethod InitMethod;
  static const InitMethod kConstant = ParamProto_InitMethod_kConstant;
  static const InitMethod kGaussain = ParamProto_InitMethod_kGaussain;
  static const InitMethod kUniform = ParamProto_InitMethod_kUniform;
  static const InitMethod kPretrained = ParamProto_InitMethod_kPretrained;
  static const InitMethod kGaussainSqrtFanIn = ParamProto_InitMethod_kGaussainSqrtFanIn;
  static const InitMethod kUniformSqrtFanIn = ParamProto_InitMethod_kUniformSqrtFanIn;
  static const InitMethod kUniformSqrtFanInOut = ParamProto_InitMethod_kUniformSqrtFanInOut;
  static inline bool InitMethod_IsValid(int value) {
    return ParamProto_InitMethod_IsValid(value);
  }
  static const InitMethod InitMethod_MIN =
    ParamProto_InitMethod_InitMethod_MIN;
  static const InitMethod InitMethod_MAX =
    ParamProto_InitMethod_InitMethod_MAX;
  static const int InitMethod_ARRAYSIZE =
    ParamProto_InitMethod_InitMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InitMethod_descriptor() {
    return ParamProto_InitMethod_descriptor();
  }
  static inline const ::std::string& InitMethod_Name(InitMethod value) {
    return ParamProto_InitMethod_Name(value);
  }
  static inline bool InitMethod_Parse(const ::std::string& name,
      InitMethod* value) {
    return ParamProto_InitMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated int32 shape = 2;
  inline int shape_size() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 2;
  inline ::google::protobuf::int32 shape(int index) const;
  inline void set_shape(int index, ::google::protobuf::int32 value);
  inline void add_shape(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shape() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shape();

  // optional .lapis.ParamProto.InitMethod init_method = 3 [default = kConstant];
  inline bool has_init_method() const;
  inline void clear_init_method();
  static const int kInitMethodFieldNumber = 3;
  inline ::lapis::ParamProto_InitMethod init_method() const;
  inline void set_init_method(::lapis::ParamProto_InitMethod value);

  // optional float value = 4 [default = 0];
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline float value() const;
  inline void set_value(float value);

  // optional float low = 5 [default = -1];
  inline bool has_low() const;
  inline void clear_low();
  static const int kLowFieldNumber = 5;
  inline float low() const;
  inline void set_low(float value);

  // optional float high = 6 [default = 1];
  inline bool has_high() const;
  inline void clear_high();
  static const int kHighFieldNumber = 6;
  inline float high() const;
  inline void set_high(float value);

  // optional float mean = 7 [default = 0];
  inline bool has_mean() const;
  inline void clear_mean();
  static const int kMeanFieldNumber = 7;
  inline float mean() const;
  inline void set_mean(float value);

  // optional float std = 8 [default = 1];
  inline bool has_std() const;
  inline void clear_std();
  static const int kStdFieldNumber = 8;
  inline float std() const;
  inline void set_std(float value);

  // optional float momentum_multiplier = 9;
  inline bool has_momentum_multiplier() const;
  inline void clear_momentum_multiplier();
  static const int kMomentumMultiplierFieldNumber = 9;
  inline float momentum_multiplier() const;
  inline void set_momentum_multiplier(float value);

  // optional float learning_rate_multiplier = 10;
  inline bool has_learning_rate_multiplier() const;
  inline void clear_learning_rate_multiplier();
  static const int kLearningRateMultiplierFieldNumber = 10;
  inline float learning_rate_multiplier() const;
  inline void set_learning_rate_multiplier(float value);

  // optional float weight_decay_multiplier = 11;
  inline bool has_weight_decay_multiplier() const;
  inline void clear_weight_decay_multiplier();
  static const int kWeightDecayMultiplierFieldNumber = 11;
  inline float weight_decay_multiplier() const;
  inline void set_weight_decay_multiplier(float value);

  // repeated float content = 13 [packed = true];
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 13;
  inline float content(int index) const;
  inline void set_content(int index, float value);
  inline void add_content(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      content() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_content();

  // repeated float history = 14 [packed = true];
  inline int history_size() const;
  inline void clear_history();
  static const int kHistoryFieldNumber = 14;
  inline float history(int index) const;
  inline void set_history(int index, float value);
  inline void add_history(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      history() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_history();

  // @@protoc_insertion_point(class_scope:lapis.ParamProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_init_method();
  inline void clear_has_init_method();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_low();
  inline void clear_has_low();
  inline void set_has_high();
  inline void clear_has_high();
  inline void set_has_mean();
  inline void clear_has_mean();
  inline void set_has_std();
  inline void clear_has_std();
  inline void set_has_momentum_multiplier();
  inline void clear_has_momentum_multiplier();
  inline void set_has_learning_rate_multiplier();
  inline void clear_has_learning_rate_multiplier();
  inline void set_has_weight_decay_multiplier();
  inline void clear_has_weight_decay_multiplier();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shape_;
  int init_method_;
  float value_;
  float low_;
  float high_;
  float mean_;
  float std_;
  float momentum_multiplier_;
  float learning_rate_multiplier_;
  ::google::protobuf::RepeatedField< float > content_;
  mutable int _content_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > history_;
  mutable int _history_cached_byte_size_;
  float weight_decay_multiplier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_model_2eproto();
  friend void protobuf_AssignDesc_model_2eproto();
  friend void protobuf_ShutdownFile_model_2eproto();

  void InitAsDefaultInstance();
  static ParamProto* default_instance_;
};
// -------------------------------------------------------------------

class EdgeProto : public ::google::protobuf::Message {
 public:
  EdgeProto();
  virtual ~EdgeProto();

  EdgeProto(const EdgeProto& from);

  inline EdgeProto& operator=(const EdgeProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeProto& default_instance();

  void Swap(EdgeProto* other);

  // implements Message ----------------------------------------------

  EdgeProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EdgeProto& from);
  void MergeFrom(const EdgeProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EdgeProto_PoolingMethod PoolingMethod;
  static const PoolingMethod kMaxPooling = EdgeProto_PoolingMethod_kMaxPooling;
  static const PoolingMethod kAvgPooling = EdgeProto_PoolingMethod_kAvgPooling;
  static inline bool PoolingMethod_IsValid(int value) {
    return EdgeProto_PoolingMethod_IsValid(value);
  }
  static const PoolingMethod PoolingMethod_MIN =
    EdgeProto_PoolingMethod_PoolingMethod_MIN;
  static const PoolingMethod PoolingMethod_MAX =
    EdgeProto_PoolingMethod_PoolingMethod_MAX;
  static const int PoolingMethod_ARRAYSIZE =
    EdgeProto_PoolingMethod_PoolingMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PoolingMethod_descriptor() {
    return EdgeProto_PoolingMethod_descriptor();
  }
  static inline const ::std::string& PoolingMethod_Name(PoolingMethod value) {
    return EdgeProto_PoolingMethod_Name(value);
  }
  static inline bool PoolingMethod_Parse(const ::std::string& name,
      PoolingMethod* value) {
    return EdgeProto_PoolingMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional int32 num_output = 3;
  inline bool has_num_output() const;
  inline void clear_num_output();
  static const int kNumOutputFieldNumber = 3;
  inline ::google::protobuf::int32 num_output() const;
  inline void set_num_output(::google::protobuf::int32 value);

  // repeated .lapis.ParamProto param = 4;
  inline int param_size() const;
  inline void clear_param();
  static const int kParamFieldNumber = 4;
  inline const ::lapis::ParamProto& param(int index) const;
  inline ::lapis::ParamProto* mutable_param(int index);
  inline ::lapis::ParamProto* add_param();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto >&
      param() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto >*
      mutable_param();

  // optional bool directed = 5 [default = true];
  inline bool has_directed() const;
  inline void clear_directed();
  static const int kDirectedFieldNumber = 5;
  inline bool directed() const;
  inline void set_directed(bool value);

  // optional string top = 6;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 6;
  inline const ::std::string& top() const;
  inline void set_top(const ::std::string& value);
  inline void set_top(const char* value);
  inline void set_top(const char* value, size_t size);
  inline ::std::string* mutable_top();
  inline ::std::string* release_top();
  inline void set_allocated_top(::std::string* top);

  // optional string bottom = 7;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 7;
  inline const ::std::string& bottom() const;
  inline void set_bottom(const ::std::string& value);
  inline void set_bottom(const char* value);
  inline void set_bottom(const char* value, size_t size);
  inline ::std::string* mutable_bottom();
  inline ::std::string* release_bottom();
  inline void set_allocated_bottom(::std::string* bottom);

  // optional int32 kernel_size = 8;
  inline bool has_kernel_size() const;
  inline void clear_kernel_size();
  static const int kKernelSizeFieldNumber = 8;
  inline ::google::protobuf::int32 kernel_size() const;
  inline void set_kernel_size(::google::protobuf::int32 value);

  // optional int32 stride = 9;
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 9;
  inline ::google::protobuf::int32 stride() const;
  inline void set_stride(::google::protobuf::int32 value);

  // optional int32 pad = 10;
  inline bool has_pad() const;
  inline void clear_pad();
  static const int kPadFieldNumber = 10;
  inline ::google::protobuf::int32 pad() const;
  inline void set_pad(::google::protobuf::int32 value);

  // optional int32 num_groups = 11;
  inline bool has_num_groups() const;
  inline void clear_num_groups();
  static const int kNumGroupsFieldNumber = 11;
  inline ::google::protobuf::int32 num_groups() const;
  inline void set_num_groups(::google::protobuf::int32 value);

  // optional float alpha = 12;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 12;
  inline float alpha() const;
  inline void set_alpha(float value);

  // optional float beta = 13;
  inline bool has_beta() const;
  inline void clear_beta();
  static const int kBetaFieldNumber = 13;
  inline float beta() const;
  inline void set_beta(float value);

  // optional int32 local_size = 14;
  inline bool has_local_size() const;
  inline void clear_local_size();
  static const int kLocalSizeFieldNumber = 14;
  inline ::google::protobuf::int32 local_size() const;
  inline void set_local_size(::google::protobuf::int32 value);

  // optional .lapis.EdgeProto.PoolingMethod pooling_method = 15;
  inline bool has_pooling_method() const;
  inline void clear_pooling_method();
  static const int kPoolingMethodFieldNumber = 15;
  inline ::lapis::EdgeProto_PoolingMethod pooling_method() const;
  inline void set_pooling_method(::lapis::EdgeProto_PoolingMethod value);

  // @@protoc_insertion_point(class_scope:lapis.EdgeProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_num_output();
  inline void clear_has_num_output();
  inline void set_has_directed();
  inline void clear_has_directed();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();
  inline void set_has_kernel_size();
  inline void clear_has_kernel_size();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_pad();
  inline void clear_has_pad();
  inline void set_has_num_groups();
  inline void clear_has_num_groups();
  inline void set_has_alpha();
  inline void clear_has_alpha();
  inline void set_has_beta();
  inline void clear_has_beta();
  inline void set_has_local_size();
  inline void clear_has_local_size();
  inline void set_has_pooling_method();
  inline void clear_has_pooling_method();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* type_;
  ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto > param_;
  ::google::protobuf::int32 num_output_;
  bool directed_;
  ::std::string* top_;
  ::std::string* bottom_;
  ::google::protobuf::int32 kernel_size_;
  ::google::protobuf::int32 stride_;
  ::google::protobuf::int32 pad_;
  ::google::protobuf::int32 num_groups_;
  float alpha_;
  float beta_;
  ::google::protobuf::int32 local_size_;
  int pooling_method_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_model_2eproto();
  friend void protobuf_AssignDesc_model_2eproto();
  friend void protobuf_ShutdownFile_model_2eproto();

  void InitAsDefaultInstance();
  static EdgeProto* default_instance_;
};
// -------------------------------------------------------------------

class BlobProto : public ::google::protobuf::Message {
 public:
  BlobProto();
  virtual ~BlobProto();

  BlobProto(const BlobProto& from);

  inline BlobProto& operator=(const BlobProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobProto& default_instance();

  void Swap(BlobProto* other);

  // implements Message ----------------------------------------------

  BlobProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobProto& from);
  void MergeFrom(const BlobProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:lapis.BlobProto)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_model_2eproto();
  friend void protobuf_AssignDesc_model_2eproto();
  friend void protobuf_ShutdownFile_model_2eproto();

  void InitAsDefaultInstance();
  static BlobProto* default_instance_;
};
// -------------------------------------------------------------------

class LayerProto : public ::google::protobuf::Message {
 public:
  LayerProto();
  virtual ~LayerProto();

  LayerProto(const LayerProto& from);

  inline LayerProto& operator=(const LayerProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LayerProto& default_instance();

  void Swap(LayerProto* other);

  // implements Message ----------------------------------------------

  LayerProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LayerProto& from);
  void MergeFrom(const LayerProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string data_source = 7;
  inline bool has_data_source() const;
  inline void clear_data_source();
  static const int kDataSourceFieldNumber = 7;
  inline const ::std::string& data_source() const;
  inline void set_data_source(const ::std::string& value);
  inline void set_data_source(const char* value);
  inline void set_data_source(const char* value, size_t size);
  inline ::std::string* mutable_data_source();
  inline ::std::string* release_data_source();
  inline void set_allocated_data_source(::std::string* data_source);

  // optional float drop_prob = 8 [default = 0];
  inline bool has_drop_prob() const;
  inline void clear_drop_prob();
  static const int kDropProbFieldNumber = 8;
  inline float drop_prob() const;
  inline void set_drop_prob(float value);

  // @@protoc_insertion_point(class_scope:lapis.LayerProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data_source();
  inline void clear_has_data_source();
  inline void set_has_drop_prob();
  inline void clear_has_drop_prob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* type_;
  ::std::string* data_source_;
  float drop_prob_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_model_2eproto();
  friend void protobuf_AssignDesc_model_2eproto();
  friend void protobuf_ShutdownFile_model_2eproto();

  void InitAsDefaultInstance();
  static LayerProto* default_instance_;
};
// -------------------------------------------------------------------

class NetProto : public ::google::protobuf::Message {
 public:
  NetProto();
  virtual ~NetProto();

  NetProto(const NetProto& from);

  inline NetProto& operator=(const NetProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetProto& default_instance();

  void Swap(NetProto* other);

  // implements Message ----------------------------------------------

  NetProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetProto& from);
  void MergeFrom(const NetProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lapis.LayerProto layer = 3;
  inline int layer_size() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 3;
  inline const ::lapis::LayerProto& layer(int index) const;
  inline ::lapis::LayerProto* mutable_layer(int index);
  inline ::lapis::LayerProto* add_layer();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::LayerProto >&
      layer() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::LayerProto >*
      mutable_layer();

  // repeated .lapis.EdgeProto edge = 4;
  inline int edge_size() const;
  inline void clear_edge();
  static const int kEdgeFieldNumber = 4;
  inline const ::lapis::EdgeProto& edge(int index) const;
  inline ::lapis::EdgeProto* mutable_edge(int index);
  inline ::lapis::EdgeProto* add_edge();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::EdgeProto >&
      edge() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::EdgeProto >*
      mutable_edge();

  // @@protoc_insertion_point(class_scope:lapis.NetProto)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::lapis::LayerProto > layer_;
  ::google::protobuf::RepeatedPtrField< ::lapis::EdgeProto > edge_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_model_2eproto();
  friend void protobuf_AssignDesc_model_2eproto();
  friend void protobuf_ShutdownFile_model_2eproto();

  void InitAsDefaultInstance();
  static NetProto* default_instance_;
};
// -------------------------------------------------------------------

class SGDProto : public ::google::protobuf::Message {
 public:
  SGDProto();
  virtual ~SGDProto();

  SGDProto(const SGDProto& from);

  inline SGDProto& operator=(const SGDProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SGDProto& default_instance();

  void Swap(SGDProto* other);

  // implements Message ----------------------------------------------

  SGDProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SGDProto& from);
  void MergeFrom(const SGDProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SGDProto_ChangeProto ChangeProto;
  static const ChangeProto kFixed = SGDProto_ChangeProto_kFixed;
  static const ChangeProto kInverse_t = SGDProto_ChangeProto_kInverse_t;
  static const ChangeProto kExponential = SGDProto_ChangeProto_kExponential;
  static const ChangeProto kLinear = SGDProto_ChangeProto_kLinear;
  static const ChangeProto kStep = SGDProto_ChangeProto_kStep;
  static inline bool ChangeProto_IsValid(int value) {
    return SGDProto_ChangeProto_IsValid(value);
  }
  static const ChangeProto ChangeProto_MIN =
    SGDProto_ChangeProto_ChangeProto_MIN;
  static const ChangeProto ChangeProto_MAX =
    SGDProto_ChangeProto_ChangeProto_MAX;
  static const int ChangeProto_ARRAYSIZE =
    SGDProto_ChangeProto_ChangeProto_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ChangeProto_descriptor() {
    return SGDProto_ChangeProto_descriptor();
  }
  static inline const ::std::string& ChangeProto_Name(ChangeProto value) {
    return SGDProto_ChangeProto_Name(value);
  }
  static inline bool ChangeProto_Parse(const ::std::string& name,
      ChangeProto* value) {
    return SGDProto_ChangeProto_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required float base_learning_rate = 1;
  inline bool has_base_learning_rate() const;
  inline void clear_base_learning_rate();
  static const int kBaseLearningRateFieldNumber = 1;
  inline float base_learning_rate() const;
  inline void set_base_learning_rate(float value);

  // optional float base_momentum = 2 [default = 0];
  inline bool has_base_momentum() const;
  inline void clear_base_momentum();
  static const int kBaseMomentumFieldNumber = 2;
  inline float base_momentum() const;
  inline void set_base_momentum(float value);

  // optional float base_weight_decay = 3 [default = 0];
  inline bool has_base_weight_decay() const;
  inline void clear_base_weight_decay();
  static const int kBaseWeightDecayFieldNumber = 3;
  inline float base_weight_decay() const;
  inline void set_base_weight_decay(float value);

  // optional float momentum_x = 4;
  inline bool has_momentum_x() const;
  inline void clear_momentum_x();
  static const int kMomentumXFieldNumber = 4;
  inline float momentum_x() const;
  inline void set_momentum_x(float value);

  // optional float learning_rate_x = 5;
  inline bool has_learning_rate_x() const;
  inline void clear_learning_rate_x();
  static const int kLearningRateXFieldNumber = 5;
  inline float learning_rate_x() const;
  inline void set_learning_rate_x(float value);

  // optional float weight_decay_x = 6;
  inline bool has_weight_decay_x() const;
  inline void clear_weight_decay_x();
  static const int kWeightDecayXFieldNumber = 6;
  inline float weight_decay_x() const;
  inline void set_weight_decay_x(float value);

  // optional int32 learning_rate_change_steps = 7;
  inline bool has_learning_rate_change_steps() const;
  inline void clear_learning_rate_change_steps();
  static const int kLearningRateChangeStepsFieldNumber = 7;
  inline ::google::protobuf::int32 learning_rate_change_steps() const;
  inline void set_learning_rate_change_steps(::google::protobuf::int32 value);

  // optional int32 momentum_change_steps = 8;
  inline bool has_momentum_change_steps() const;
  inline void clear_momentum_change_steps();
  static const int kMomentumChangeStepsFieldNumber = 8;
  inline ::google::protobuf::int32 momentum_change_steps() const;
  inline void set_momentum_change_steps(::google::protobuf::int32 value);

  // optional int32 weight_decay_change_steps = 9;
  inline bool has_weight_decay_change_steps() const;
  inline void clear_weight_decay_change_steps();
  static const int kWeightDecayChangeStepsFieldNumber = 9;
  inline ::google::protobuf::int32 weight_decay_change_steps() const;
  inline void set_weight_decay_change_steps(::google::protobuf::int32 value);

  // optional .lapis.SGDProto.ChangeProto learning_rate_change = 10 [default = kInverse_t];
  inline bool has_learning_rate_change() const;
  inline void clear_learning_rate_change();
  static const int kLearningRateChangeFieldNumber = 10;
  inline ::lapis::SGDProto_ChangeProto learning_rate_change() const;
  inline void set_learning_rate_change(::lapis::SGDProto_ChangeProto value);

  // optional .lapis.SGDProto.ChangeProto weight_decay_change = 11 [default = kFixed];
  inline bool has_weight_decay_change() const;
  inline void clear_weight_decay_change();
  static const int kWeightDecayChangeFieldNumber = 11;
  inline ::lapis::SGDProto_ChangeProto weight_decay_change() const;
  inline void set_weight_decay_change(::lapis::SGDProto_ChangeProto value);

  // optional .lapis.SGDProto.ChangeProto momentum_change = 12 [default = kFixed];
  inline bool has_momentum_change() const;
  inline void clear_momentum_change();
  static const int kMomentumChangeFieldNumber = 12;
  inline ::lapis::SGDProto_ChangeProto momentum_change() const;
  inline void set_momentum_change(::lapis::SGDProto_ChangeProto value);

  // optional int32 total_steps = 13;
  inline bool has_total_steps() const;
  inline void clear_total_steps();
  static const int kTotalStepsFieldNumber = 13;
  inline ::google::protobuf::int32 total_steps() const;
  inline void set_total_steps(::google::protobuf::int32 value);

  // optional int32 train_batchsize = 14;
  inline bool has_train_batchsize() const;
  inline void clear_train_batchsize();
  static const int kTrainBatchsizeFieldNumber = 14;
  inline ::google::protobuf::int32 train_batchsize() const;
  inline void set_train_batchsize(::google::protobuf::int32 value);

  // optional int32 validation_batchsize = 15;
  inline bool has_validation_batchsize() const;
  inline void clear_validation_batchsize();
  static const int kValidationBatchsizeFieldNumber = 15;
  inline ::google::protobuf::int32 validation_batchsize() const;
  inline void set_validation_batchsize(::google::protobuf::int32 value);

  // optional int32 test_batchsize = 16;
  inline bool has_test_batchsize() const;
  inline void clear_test_batchsize();
  static const int kTestBatchsizeFieldNumber = 16;
  inline ::google::protobuf::int32 test_batchsize() const;
  inline void set_test_batchsize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lapis.SGDProto)
 private:
  inline void set_has_base_learning_rate();
  inline void clear_has_base_learning_rate();
  inline void set_has_base_momentum();
  inline void clear_has_base_momentum();
  inline void set_has_base_weight_decay();
  inline void clear_has_base_weight_decay();
  inline void set_has_momentum_x();
  inline void clear_has_momentum_x();
  inline void set_has_learning_rate_x();
  inline void clear_has_learning_rate_x();
  inline void set_has_weight_decay_x();
  inline void clear_has_weight_decay_x();
  inline void set_has_learning_rate_change_steps();
  inline void clear_has_learning_rate_change_steps();
  inline void set_has_momentum_change_steps();
  inline void clear_has_momentum_change_steps();
  inline void set_has_weight_decay_change_steps();
  inline void clear_has_weight_decay_change_steps();
  inline void set_has_learning_rate_change();
  inline void clear_has_learning_rate_change();
  inline void set_has_weight_decay_change();
  inline void clear_has_weight_decay_change();
  inline void set_has_momentum_change();
  inline void clear_has_momentum_change();
  inline void set_has_total_steps();
  inline void clear_has_total_steps();
  inline void set_has_train_batchsize();
  inline void clear_has_train_batchsize();
  inline void set_has_validation_batchsize();
  inline void clear_has_validation_batchsize();
  inline void set_has_test_batchsize();
  inline void clear_has_test_batchsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float base_learning_rate_;
  float base_momentum_;
  float base_weight_decay_;
  float momentum_x_;
  float learning_rate_x_;
  float weight_decay_x_;
  ::google::protobuf::int32 learning_rate_change_steps_;
  ::google::protobuf::int32 momentum_change_steps_;
  ::google::protobuf::int32 weight_decay_change_steps_;
  int learning_rate_change_;
  int weight_decay_change_;
  int momentum_change_;
  ::google::protobuf::int32 total_steps_;
  ::google::protobuf::int32 train_batchsize_;
  ::google::protobuf::int32 validation_batchsize_;
  ::google::protobuf::int32 test_batchsize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_model_2eproto();
  friend void protobuf_AssignDesc_model_2eproto();
  friend void protobuf_ShutdownFile_model_2eproto();

  void InitAsDefaultInstance();
  static SGDProto* default_instance_;
};
// -------------------------------------------------------------------

class PerformanceProto : public ::google::protobuf::Message {
 public:
  PerformanceProto();
  virtual ~PerformanceProto();

  PerformanceProto(const PerformanceProto& from);

  inline PerformanceProto& operator=(const PerformanceProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerformanceProto& default_instance();

  void Swap(PerformanceProto* other);

  // implements Message ----------------------------------------------

  PerformanceProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PerformanceProto& from);
  void MergeFrom(const PerformanceProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float precision = 1;
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 1;
  inline float precision() const;
  inline void set_precision(float value);

  // optional float recall = 2;
  inline bool has_recall() const;
  inline void clear_recall();
  static const int kRecallFieldNumber = 2;
  inline float recall() const;
  inline void set_recall(float value);

  // optional float map = 3;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 3;
  inline float map() const;
  inline void set_map(float value);

  // optional float precision50 = 4;
  inline bool has_precision50() const;
  inline void clear_precision50();
  static const int kPrecision50FieldNumber = 4;
  inline float precision50() const;
  inline void set_precision50(float value);

  // @@protoc_insertion_point(class_scope:lapis.PerformanceProto)
 private:
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_recall();
  inline void clear_has_recall();
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_precision50();
  inline void clear_has_precision50();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float precision_;
  float recall_;
  float map_;
  float precision50_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_model_2eproto();
  friend void protobuf_AssignDesc_model_2eproto();
  friend void protobuf_ShutdownFile_model_2eproto();

  void InitAsDefaultInstance();
  static PerformanceProto* default_instance_;
};
// -------------------------------------------------------------------

class TrainerProto : public ::google::protobuf::Message {
 public:
  TrainerProto();
  virtual ~TrainerProto();

  TrainerProto(const TrainerProto& from);

  inline TrainerProto& operator=(const TrainerProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrainerProto& default_instance();

  void Swap(TrainerProto* other);

  // implements Message ----------------------------------------------

  TrainerProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrainerProto& from);
  void MergeFrom(const TrainerProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TrainerProto_Algorithm Algorithm;
  static const Algorithm kBackPropagation = TrainerProto_Algorithm_kBackPropagation;
  static const Algorithm kContrastiveDivergence = TrainerProto_Algorithm_kContrastiveDivergence;
  static inline bool Algorithm_IsValid(int value) {
    return TrainerProto_Algorithm_IsValid(value);
  }
  static const Algorithm Algorithm_MIN =
    TrainerProto_Algorithm_Algorithm_MIN;
  static const Algorithm Algorithm_MAX =
    TrainerProto_Algorithm_Algorithm_MAX;
  static const int Algorithm_ARRAYSIZE =
    TrainerProto_Algorithm_Algorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Algorithm_descriptor() {
    return TrainerProto_Algorithm_descriptor();
  }
  static inline const ::std::string& Algorithm_Name(Algorithm value) {
    return TrainerProto_Algorithm_Name(value);
  }
  static inline bool Algorithm_Parse(const ::std::string& name,
      Algorithm* value) {
    return TrainerProto_Algorithm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .lapis.SGDProto sgd = 1;
  inline bool has_sgd() const;
  inline void clear_sgd();
  static const int kSgdFieldNumber = 1;
  inline const ::lapis::SGDProto& sgd() const;
  inline ::lapis::SGDProto* mutable_sgd();
  inline ::lapis::SGDProto* release_sgd();
  inline void set_allocated_sgd(::lapis::SGDProto* sgd);

  // optional int32 checkpoint_after_steps = 2 [default = 0];
  inline bool has_checkpoint_after_steps() const;
  inline void clear_checkpoint_after_steps();
  static const int kCheckpointAfterStepsFieldNumber = 2;
  inline ::google::protobuf::int32 checkpoint_after_steps() const;
  inline void set_checkpoint_after_steps(::google::protobuf::int32 value);

  // optional int32 checkpoint_every_steps = 3 [default = 0];
  inline bool has_checkpoint_every_steps() const;
  inline void clear_checkpoint_every_steps();
  static const int kCheckpointEveryStepsFieldNumber = 3;
  inline ::google::protobuf::int32 checkpoint_every_steps() const;
  inline void set_checkpoint_every_steps(::google::protobuf::int32 value);

  // optional string checkpoint_prefix = 4 [default = "tmp/checkpoint"];
  inline bool has_checkpoint_prefix() const;
  inline void clear_checkpoint_prefix();
  static const int kCheckpointPrefixFieldNumber = 4;
  inline const ::std::string& checkpoint_prefix() const;
  inline void set_checkpoint_prefix(const ::std::string& value);
  inline void set_checkpoint_prefix(const char* value);
  inline void set_checkpoint_prefix(const char* value, size_t size);
  inline ::std::string* mutable_checkpoint_prefix();
  inline ::std::string* release_checkpoint_prefix();
  inline void set_allocated_checkpoint_prefix(::std::string* checkpoint_prefix);

  // optional int32 checkpoint_step = 5 [default = 0];
  inline bool has_checkpoint_step() const;
  inline void clear_checkpoint_step();
  static const int kCheckpointStepFieldNumber = 5;
  inline ::google::protobuf::int32 checkpoint_step() const;
  inline void set_checkpoint_step(::google::protobuf::int32 value);

  // optional int32 display_after_steps = 6 [default = 0];
  inline bool has_display_after_steps() const;
  inline void clear_display_after_steps();
  static const int kDisplayAfterStepsFieldNumber = 6;
  inline ::google::protobuf::int32 display_after_steps() const;
  inline void set_display_after_steps(::google::protobuf::int32 value);

  // optional int32 display_every_steps = 7 [default = 0];
  inline bool has_display_every_steps() const;
  inline void clear_display_every_steps();
  static const int kDisplayEveryStepsFieldNumber = 7;
  inline ::google::protobuf::int32 display_every_steps() const;
  inline void set_display_every_steps(::google::protobuf::int32 value);

  // optional string display_prefix = 8 [default = "tmp/display"];
  inline bool has_display_prefix() const;
  inline void clear_display_prefix();
  static const int kDisplayPrefixFieldNumber = 8;
  inline const ::std::string& display_prefix() const;
  inline void set_display_prefix(const ::std::string& value);
  inline void set_display_prefix(const char* value);
  inline void set_display_prefix(const char* value, size_t size);
  inline ::std::string* mutable_display_prefix();
  inline ::std::string* release_display_prefix();
  inline void set_allocated_display_prefix(::std::string* display_prefix);

  // optional int32 validate_step = 9 [default = 0];
  inline bool has_validate_step() const;
  inline void clear_validate_step();
  static const int kValidateStepFieldNumber = 9;
  inline ::google::protobuf::int32 validate_step() const;
  inline void set_validate_step(::google::protobuf::int32 value);

  // optional int32 validate_after_steps = 10 [default = 0];
  inline bool has_validate_after_steps() const;
  inline void clear_validate_after_steps();
  static const int kValidateAfterStepsFieldNumber = 10;
  inline ::google::protobuf::int32 validate_after_steps() const;
  inline void set_validate_after_steps(::google::protobuf::int32 value);

  // optional int32 validate_every_steps = 11 [default = 0];
  inline bool has_validate_every_steps() const;
  inline void clear_validate_every_steps();
  static const int kValidateEveryStepsFieldNumber = 11;
  inline ::google::protobuf::int32 validate_every_steps() const;
  inline void set_validate_every_steps(::google::protobuf::int32 value);

  // repeated .lapis.DataSourceProto train_data = 12;
  inline int train_data_size() const;
  inline void clear_train_data();
  static const int kTrainDataFieldNumber = 12;
  inline const ::lapis::DataSourceProto& train_data(int index) const;
  inline ::lapis::DataSourceProto* mutable_train_data(int index);
  inline ::lapis::DataSourceProto* add_train_data();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >&
      train_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >*
      mutable_train_data();

  // repeated .lapis.DataSourceProto validation_data = 13;
  inline int validation_data_size() const;
  inline void clear_validation_data();
  static const int kValidationDataFieldNumber = 13;
  inline const ::lapis::DataSourceProto& validation_data(int index) const;
  inline ::lapis::DataSourceProto* mutable_validation_data(int index);
  inline ::lapis::DataSourceProto* add_validation_data();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >&
      validation_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >*
      mutable_validation_data();

  // repeated .lapis.DataSourceProto test_data = 14;
  inline int test_data_size() const;
  inline void clear_test_data();
  static const int kTestDataFieldNumber = 14;
  inline const ::lapis::DataSourceProto& test_data(int index) const;
  inline ::lapis::DataSourceProto* mutable_test_data(int index);
  inline ::lapis::DataSourceProto* add_test_data();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >&
      test_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >*
      mutable_test_data();

  // optional string perf_prefix = 15 [default = "tmp/performance"];
  inline bool has_perf_prefix() const;
  inline void clear_perf_prefix();
  static const int kPerfPrefixFieldNumber = 15;
  inline const ::std::string& perf_prefix() const;
  inline void set_perf_prefix(const ::std::string& value);
  inline void set_perf_prefix(const char* value);
  inline void set_perf_prefix(const char* value, size_t size);
  inline ::std::string* mutable_perf_prefix();
  inline ::std::string* release_perf_prefix();
  inline void set_allocated_perf_prefix(::std::string* perf_prefix);

  // optional .lapis.TrainerProto.Algorithm alg = 16 [default = kBackPropagation];
  inline bool has_alg() const;
  inline void clear_alg();
  static const int kAlgFieldNumber = 16;
  inline ::lapis::TrainerProto_Algorithm alg() const;
  inline void set_alg(::lapis::TrainerProto_Algorithm value);

  // optional bool do_train = 17 [default = true];
  inline bool has_do_train() const;
  inline void clear_do_train();
  static const int kDoTrainFieldNumber = 17;
  inline bool do_train() const;
  inline void set_do_train(bool value);

  // optional bool do_test = 18 [default = false];
  inline bool has_do_test() const;
  inline void clear_do_test();
  static const int kDoTestFieldNumber = 18;
  inline bool do_test() const;
  inline void set_do_test(bool value);

  // @@protoc_insertion_point(class_scope:lapis.TrainerProto)
 private:
  inline void set_has_sgd();
  inline void clear_has_sgd();
  inline void set_has_checkpoint_after_steps();
  inline void clear_has_checkpoint_after_steps();
  inline void set_has_checkpoint_every_steps();
  inline void clear_has_checkpoint_every_steps();
  inline void set_has_checkpoint_prefix();
  inline void clear_has_checkpoint_prefix();
  inline void set_has_checkpoint_step();
  inline void clear_has_checkpoint_step();
  inline void set_has_display_after_steps();
  inline void clear_has_display_after_steps();
  inline void set_has_display_every_steps();
  inline void clear_has_display_every_steps();
  inline void set_has_display_prefix();
  inline void clear_has_display_prefix();
  inline void set_has_validate_step();
  inline void clear_has_validate_step();
  inline void set_has_validate_after_steps();
  inline void clear_has_validate_after_steps();
  inline void set_has_validate_every_steps();
  inline void clear_has_validate_every_steps();
  inline void set_has_perf_prefix();
  inline void clear_has_perf_prefix();
  inline void set_has_alg();
  inline void clear_has_alg();
  inline void set_has_do_train();
  inline void clear_has_do_train();
  inline void set_has_do_test();
  inline void clear_has_do_test();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::lapis::SGDProto* sgd_;
  ::google::protobuf::int32 checkpoint_after_steps_;
  ::google::protobuf::int32 checkpoint_every_steps_;
  ::std::string* checkpoint_prefix_;
  static ::std::string* _default_checkpoint_prefix_;
  ::google::protobuf::int32 checkpoint_step_;
  ::google::protobuf::int32 display_after_steps_;
  ::std::string* display_prefix_;
  static ::std::string* _default_display_prefix_;
  ::google::protobuf::int32 display_every_steps_;
  ::google::protobuf::int32 validate_step_;
  ::google::protobuf::int32 validate_after_steps_;
  ::google::protobuf::int32 validate_every_steps_;
  ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto > train_data_;
  ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto > validation_data_;
  ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto > test_data_;
  ::std::string* perf_prefix_;
  static ::std::string* _default_perf_prefix_;
  int alg_;
  bool do_train_;
  bool do_test_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_model_2eproto();
  friend void protobuf_AssignDesc_model_2eproto();
  friend void protobuf_ShutdownFile_model_2eproto();

  void InitAsDefaultInstance();
  static TrainerProto* default_instance_;
};
// -------------------------------------------------------------------

class ModelProto : public ::google::protobuf::Message {
 public:
  ModelProto();
  virtual ~ModelProto();

  ModelProto(const ModelProto& from);

  inline ModelProto& operator=(const ModelProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelProto& default_instance();

  void Swap(ModelProto* other);

  // implements Message ----------------------------------------------

  ModelProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelProto& from);
  void MergeFrom(const ModelProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .lapis.NetProto net = 2;
  inline bool has_net() const;
  inline void clear_net();
  static const int kNetFieldNumber = 2;
  inline const ::lapis::NetProto& net() const;
  inline ::lapis::NetProto* mutable_net();
  inline ::lapis::NetProto* release_net();
  inline void set_allocated_net(::lapis::NetProto* net);

  // required .lapis.TrainerProto trainer = 3;
  inline bool has_trainer() const;
  inline void clear_trainer();
  static const int kTrainerFieldNumber = 3;
  inline const ::lapis::TrainerProto& trainer() const;
  inline ::lapis::TrainerProto* mutable_trainer();
  inline ::lapis::TrainerProto* release_trainer();
  inline void set_allocated_trainer(::lapis::TrainerProto* trainer);

  // @@protoc_insertion_point(class_scope:lapis.ModelProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_net();
  inline void clear_has_net();
  inline void set_has_trainer();
  inline void clear_has_trainer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::lapis::NetProto* net_;
  ::lapis::TrainerProto* trainer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_model_2eproto();
  friend void protobuf_AssignDesc_model_2eproto();
  friend void protobuf_ShutdownFile_model_2eproto();

  void InitAsDefaultInstance();
  static ModelProto* default_instance_;
};
// -------------------------------------------------------------------

class float_vector_message : public ::google::protobuf::Message {
 public:
  float_vector_message();
  virtual ~float_vector_message();

  float_vector_message(const float_vector_message& from);

  inline float_vector_message& operator=(const float_vector_message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const float_vector_message& default_instance();

  void Swap(float_vector_message* other);

  // implements Message ----------------------------------------------

  float_vector_message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const float_vector_message& from);
  void MergeFrom(const float_vector_message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float myfloat = 1;
  inline int myfloat_size() const;
  inline void clear_myfloat();
  static const int kMyfloatFieldNumber = 1;
  inline float myfloat(int index) const;
  inline void set_myfloat(int index, float value);
  inline void add_myfloat(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      myfloat() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_myfloat();

  // @@protoc_insertion_point(class_scope:lapis.float_vector_message)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > myfloat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_model_2eproto();
  friend void protobuf_AssignDesc_model_2eproto();
  friend void protobuf_ShutdownFile_model_2eproto();

  void InitAsDefaultInstance();
  static float_vector_message* default_instance_;
};
// ===================================================================


// ===================================================================

// DataSourceProto

// required string name = 1;
inline bool DataSourceProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataSourceProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataSourceProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataSourceProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DataSourceProto::name() const {
  return *name_;
}
inline void DataSourceProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DataSourceProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DataSourceProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataSourceProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DataSourceProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataSourceProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string id = 2;
inline bool DataSourceProto::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataSourceProto::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataSourceProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataSourceProto::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& DataSourceProto::id() const {
  return *id_;
}
inline void DataSourceProto::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void DataSourceProto::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void DataSourceProto::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataSourceProto::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* DataSourceProto::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataSourceProto::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 3;
inline bool DataSourceProto::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataSourceProto::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataSourceProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataSourceProto::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& DataSourceProto::path() const {
  return *path_;
}
inline void DataSourceProto::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void DataSourceProto::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void DataSourceProto::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataSourceProto::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* DataSourceProto::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataSourceProto::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 size = 4;
inline bool DataSourceProto::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataSourceProto::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataSourceProto::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataSourceProto::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 DataSourceProto::size() const {
  return size_;
}
inline void DataSourceProto::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// optional int32 channels = 6 [default = 1];
inline bool DataSourceProto::has_channels() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataSourceProto::set_has_channels() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataSourceProto::clear_has_channels() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataSourceProto::clear_channels() {
  channels_ = 1;
  clear_has_channels();
}
inline ::google::protobuf::int32 DataSourceProto::channels() const {
  return channels_;
}
inline void DataSourceProto::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
}

// optional int32 height = 7 [default = 0];
inline bool DataSourceProto::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataSourceProto::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataSourceProto::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataSourceProto::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 DataSourceProto::height() const {
  return height_;
}
inline void DataSourceProto::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 width = 8 [default = 0];
inline bool DataSourceProto::has_width() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataSourceProto::set_has_width() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataSourceProto::clear_has_width() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataSourceProto::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 DataSourceProto::width() const {
  return width_;
}
inline void DataSourceProto::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int64 offset = 9 [default = 0];
inline bool DataSourceProto::has_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataSourceProto::set_has_offset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataSourceProto::clear_has_offset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataSourceProto::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 DataSourceProto::offset() const {
  return offset_;
}
inline void DataSourceProto::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// RGBDatum

// optional int32 channels = 1 [default = 3];
inline bool RGBDatum::has_channels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RGBDatum::set_has_channels() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RGBDatum::clear_has_channels() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RGBDatum::clear_channels() {
  channels_ = 3;
  clear_has_channels();
}
inline ::google::protobuf::int32 RGBDatum::channels() const {
  return channels_;
}
inline void RGBDatum::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
}

// optional int32 height = 2 [default = 0];
inline bool RGBDatum::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RGBDatum::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RGBDatum::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RGBDatum::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 RGBDatum::height() const {
  return height_;
}
inline void RGBDatum::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 width = 3 [default = 0];
inline bool RGBDatum::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RGBDatum::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RGBDatum::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RGBDatum::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 RGBDatum::width() const {
  return width_;
}
inline void RGBDatum::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// required string content = 4;
inline bool RGBDatum::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RGBDatum::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RGBDatum::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RGBDatum::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& RGBDatum::content() const {
  return *content_;
}
inline void RGBDatum::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void RGBDatum::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void RGBDatum::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RGBDatum::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* RGBDatum::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RGBDatum::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ParamProto

// required string name = 1;
inline bool ParamProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParamProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParamProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParamProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ParamProto::name() const {
  return *name_;
}
inline void ParamProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ParamProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ParamProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParamProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ParamProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParamProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int32 shape = 2;
inline int ParamProto::shape_size() const {
  return shape_.size();
}
inline void ParamProto::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int32 ParamProto::shape(int index) const {
  return shape_.Get(index);
}
inline void ParamProto::set_shape(int index, ::google::protobuf::int32 value) {
  shape_.Set(index, value);
}
inline void ParamProto::add_shape(::google::protobuf::int32 value) {
  shape_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ParamProto::shape() const {
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ParamProto::mutable_shape() {
  return &shape_;
}

// optional .lapis.ParamProto.InitMethod init_method = 3 [default = kConstant];
inline bool ParamProto::has_init_method() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParamProto::set_has_init_method() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParamProto::clear_has_init_method() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParamProto::clear_init_method() {
  init_method_ = 0;
  clear_has_init_method();
}
inline ::lapis::ParamProto_InitMethod ParamProto::init_method() const {
  return static_cast< ::lapis::ParamProto_InitMethod >(init_method_);
}
inline void ParamProto::set_init_method(::lapis::ParamProto_InitMethod value) {
  assert(::lapis::ParamProto_InitMethod_IsValid(value));
  set_has_init_method();
  init_method_ = value;
}

// optional float value = 4 [default = 0];
inline bool ParamProto::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParamProto::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParamProto::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParamProto::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float ParamProto::value() const {
  return value_;
}
inline void ParamProto::set_value(float value) {
  set_has_value();
  value_ = value;
}

// optional float low = 5 [default = -1];
inline bool ParamProto::has_low() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ParamProto::set_has_low() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ParamProto::clear_has_low() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ParamProto::clear_low() {
  low_ = -1;
  clear_has_low();
}
inline float ParamProto::low() const {
  return low_;
}
inline void ParamProto::set_low(float value) {
  set_has_low();
  low_ = value;
}

// optional float high = 6 [default = 1];
inline bool ParamProto::has_high() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ParamProto::set_has_high() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ParamProto::clear_has_high() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ParamProto::clear_high() {
  high_ = 1;
  clear_has_high();
}
inline float ParamProto::high() const {
  return high_;
}
inline void ParamProto::set_high(float value) {
  set_has_high();
  high_ = value;
}

// optional float mean = 7 [default = 0];
inline bool ParamProto::has_mean() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ParamProto::set_has_mean() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ParamProto::clear_has_mean() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ParamProto::clear_mean() {
  mean_ = 0;
  clear_has_mean();
}
inline float ParamProto::mean() const {
  return mean_;
}
inline void ParamProto::set_mean(float value) {
  set_has_mean();
  mean_ = value;
}

// optional float std = 8 [default = 1];
inline bool ParamProto::has_std() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ParamProto::set_has_std() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ParamProto::clear_has_std() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ParamProto::clear_std() {
  std_ = 1;
  clear_has_std();
}
inline float ParamProto::std() const {
  return std_;
}
inline void ParamProto::set_std(float value) {
  set_has_std();
  std_ = value;
}

// optional float momentum_multiplier = 9;
inline bool ParamProto::has_momentum_multiplier() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ParamProto::set_has_momentum_multiplier() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ParamProto::clear_has_momentum_multiplier() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ParamProto::clear_momentum_multiplier() {
  momentum_multiplier_ = 0;
  clear_has_momentum_multiplier();
}
inline float ParamProto::momentum_multiplier() const {
  return momentum_multiplier_;
}
inline void ParamProto::set_momentum_multiplier(float value) {
  set_has_momentum_multiplier();
  momentum_multiplier_ = value;
}

// optional float learning_rate_multiplier = 10;
inline bool ParamProto::has_learning_rate_multiplier() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ParamProto::set_has_learning_rate_multiplier() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ParamProto::clear_has_learning_rate_multiplier() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ParamProto::clear_learning_rate_multiplier() {
  learning_rate_multiplier_ = 0;
  clear_has_learning_rate_multiplier();
}
inline float ParamProto::learning_rate_multiplier() const {
  return learning_rate_multiplier_;
}
inline void ParamProto::set_learning_rate_multiplier(float value) {
  set_has_learning_rate_multiplier();
  learning_rate_multiplier_ = value;
}

// optional float weight_decay_multiplier = 11;
inline bool ParamProto::has_weight_decay_multiplier() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ParamProto::set_has_weight_decay_multiplier() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ParamProto::clear_has_weight_decay_multiplier() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ParamProto::clear_weight_decay_multiplier() {
  weight_decay_multiplier_ = 0;
  clear_has_weight_decay_multiplier();
}
inline float ParamProto::weight_decay_multiplier() const {
  return weight_decay_multiplier_;
}
inline void ParamProto::set_weight_decay_multiplier(float value) {
  set_has_weight_decay_multiplier();
  weight_decay_multiplier_ = value;
}

// repeated float content = 13 [packed = true];
inline int ParamProto::content_size() const {
  return content_.size();
}
inline void ParamProto::clear_content() {
  content_.Clear();
}
inline float ParamProto::content(int index) const {
  return content_.Get(index);
}
inline void ParamProto::set_content(int index, float value) {
  content_.Set(index, value);
}
inline void ParamProto::add_content(float value) {
  content_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ParamProto::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedField< float >*
ParamProto::mutable_content() {
  return &content_;
}

// repeated float history = 14 [packed = true];
inline int ParamProto::history_size() const {
  return history_.size();
}
inline void ParamProto::clear_history() {
  history_.Clear();
}
inline float ParamProto::history(int index) const {
  return history_.Get(index);
}
inline void ParamProto::set_history(int index, float value) {
  history_.Set(index, value);
}
inline void ParamProto::add_history(float value) {
  history_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ParamProto::history() const {
  return history_;
}
inline ::google::protobuf::RepeatedField< float >*
ParamProto::mutable_history() {
  return &history_;
}

// -------------------------------------------------------------------

// EdgeProto

// required string name = 1;
inline bool EdgeProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EdgeProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EdgeProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EdgeProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EdgeProto::name() const {
  return *name_;
}
inline void EdgeProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void EdgeProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void EdgeProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EdgeProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* EdgeProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EdgeProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string type = 2;
inline bool EdgeProto::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EdgeProto::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EdgeProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EdgeProto::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& EdgeProto::type() const {
  return *type_;
}
inline void EdgeProto::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void EdgeProto::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void EdgeProto::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EdgeProto::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* EdgeProto::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EdgeProto::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 num_output = 3;
inline bool EdgeProto::has_num_output() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EdgeProto::set_has_num_output() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EdgeProto::clear_has_num_output() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EdgeProto::clear_num_output() {
  num_output_ = 0;
  clear_has_num_output();
}
inline ::google::protobuf::int32 EdgeProto::num_output() const {
  return num_output_;
}
inline void EdgeProto::set_num_output(::google::protobuf::int32 value) {
  set_has_num_output();
  num_output_ = value;
}

// repeated .lapis.ParamProto param = 4;
inline int EdgeProto::param_size() const {
  return param_.size();
}
inline void EdgeProto::clear_param() {
  param_.Clear();
}
inline const ::lapis::ParamProto& EdgeProto::param(int index) const {
  return param_.Get(index);
}
inline ::lapis::ParamProto* EdgeProto::mutable_param(int index) {
  return param_.Mutable(index);
}
inline ::lapis::ParamProto* EdgeProto::add_param() {
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto >&
EdgeProto::param() const {
  return param_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::ParamProto >*
EdgeProto::mutable_param() {
  return &param_;
}

// optional bool directed = 5 [default = true];
inline bool EdgeProto::has_directed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EdgeProto::set_has_directed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EdgeProto::clear_has_directed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EdgeProto::clear_directed() {
  directed_ = true;
  clear_has_directed();
}
inline bool EdgeProto::directed() const {
  return directed_;
}
inline void EdgeProto::set_directed(bool value) {
  set_has_directed();
  directed_ = value;
}

// optional string top = 6;
inline bool EdgeProto::has_top() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EdgeProto::set_has_top() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EdgeProto::clear_has_top() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EdgeProto::clear_top() {
  if (top_ != &::google::protobuf::internal::kEmptyString) {
    top_->clear();
  }
  clear_has_top();
}
inline const ::std::string& EdgeProto::top() const {
  return *top_;
}
inline void EdgeProto::set_top(const ::std::string& value) {
  set_has_top();
  if (top_ == &::google::protobuf::internal::kEmptyString) {
    top_ = new ::std::string;
  }
  top_->assign(value);
}
inline void EdgeProto::set_top(const char* value) {
  set_has_top();
  if (top_ == &::google::protobuf::internal::kEmptyString) {
    top_ = new ::std::string;
  }
  top_->assign(value);
}
inline void EdgeProto::set_top(const char* value, size_t size) {
  set_has_top();
  if (top_ == &::google::protobuf::internal::kEmptyString) {
    top_ = new ::std::string;
  }
  top_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EdgeProto::mutable_top() {
  set_has_top();
  if (top_ == &::google::protobuf::internal::kEmptyString) {
    top_ = new ::std::string;
  }
  return top_;
}
inline ::std::string* EdgeProto::release_top() {
  clear_has_top();
  if (top_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = top_;
    top_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EdgeProto::set_allocated_top(::std::string* top) {
  if (top_ != &::google::protobuf::internal::kEmptyString) {
    delete top_;
  }
  if (top) {
    set_has_top();
    top_ = top;
  } else {
    clear_has_top();
    top_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bottom = 7;
inline bool EdgeProto::has_bottom() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EdgeProto::set_has_bottom() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EdgeProto::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EdgeProto::clear_bottom() {
  if (bottom_ != &::google::protobuf::internal::kEmptyString) {
    bottom_->clear();
  }
  clear_has_bottom();
}
inline const ::std::string& EdgeProto::bottom() const {
  return *bottom_;
}
inline void EdgeProto::set_bottom(const ::std::string& value) {
  set_has_bottom();
  if (bottom_ == &::google::protobuf::internal::kEmptyString) {
    bottom_ = new ::std::string;
  }
  bottom_->assign(value);
}
inline void EdgeProto::set_bottom(const char* value) {
  set_has_bottom();
  if (bottom_ == &::google::protobuf::internal::kEmptyString) {
    bottom_ = new ::std::string;
  }
  bottom_->assign(value);
}
inline void EdgeProto::set_bottom(const char* value, size_t size) {
  set_has_bottom();
  if (bottom_ == &::google::protobuf::internal::kEmptyString) {
    bottom_ = new ::std::string;
  }
  bottom_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EdgeProto::mutable_bottom() {
  set_has_bottom();
  if (bottom_ == &::google::protobuf::internal::kEmptyString) {
    bottom_ = new ::std::string;
  }
  return bottom_;
}
inline ::std::string* EdgeProto::release_bottom() {
  clear_has_bottom();
  if (bottom_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bottom_;
    bottom_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EdgeProto::set_allocated_bottom(::std::string* bottom) {
  if (bottom_ != &::google::protobuf::internal::kEmptyString) {
    delete bottom_;
  }
  if (bottom) {
    set_has_bottom();
    bottom_ = bottom;
  } else {
    clear_has_bottom();
    bottom_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 kernel_size = 8;
inline bool EdgeProto::has_kernel_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EdgeProto::set_has_kernel_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EdgeProto::clear_has_kernel_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EdgeProto::clear_kernel_size() {
  kernel_size_ = 0;
  clear_has_kernel_size();
}
inline ::google::protobuf::int32 EdgeProto::kernel_size() const {
  return kernel_size_;
}
inline void EdgeProto::set_kernel_size(::google::protobuf::int32 value) {
  set_has_kernel_size();
  kernel_size_ = value;
}

// optional int32 stride = 9;
inline bool EdgeProto::has_stride() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EdgeProto::set_has_stride() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EdgeProto::clear_has_stride() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EdgeProto::clear_stride() {
  stride_ = 0;
  clear_has_stride();
}
inline ::google::protobuf::int32 EdgeProto::stride() const {
  return stride_;
}
inline void EdgeProto::set_stride(::google::protobuf::int32 value) {
  set_has_stride();
  stride_ = value;
}

// optional int32 pad = 10;
inline bool EdgeProto::has_pad() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EdgeProto::set_has_pad() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EdgeProto::clear_has_pad() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EdgeProto::clear_pad() {
  pad_ = 0;
  clear_has_pad();
}
inline ::google::protobuf::int32 EdgeProto::pad() const {
  return pad_;
}
inline void EdgeProto::set_pad(::google::protobuf::int32 value) {
  set_has_pad();
  pad_ = value;
}

// optional int32 num_groups = 11;
inline bool EdgeProto::has_num_groups() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EdgeProto::set_has_num_groups() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EdgeProto::clear_has_num_groups() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EdgeProto::clear_num_groups() {
  num_groups_ = 0;
  clear_has_num_groups();
}
inline ::google::protobuf::int32 EdgeProto::num_groups() const {
  return num_groups_;
}
inline void EdgeProto::set_num_groups(::google::protobuf::int32 value) {
  set_has_num_groups();
  num_groups_ = value;
}

// optional float alpha = 12;
inline bool EdgeProto::has_alpha() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EdgeProto::set_has_alpha() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EdgeProto::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EdgeProto::clear_alpha() {
  alpha_ = 0;
  clear_has_alpha();
}
inline float EdgeProto::alpha() const {
  return alpha_;
}
inline void EdgeProto::set_alpha(float value) {
  set_has_alpha();
  alpha_ = value;
}

// optional float beta = 13;
inline bool EdgeProto::has_beta() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EdgeProto::set_has_beta() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EdgeProto::clear_has_beta() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EdgeProto::clear_beta() {
  beta_ = 0;
  clear_has_beta();
}
inline float EdgeProto::beta() const {
  return beta_;
}
inline void EdgeProto::set_beta(float value) {
  set_has_beta();
  beta_ = value;
}

// optional int32 local_size = 14;
inline bool EdgeProto::has_local_size() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EdgeProto::set_has_local_size() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EdgeProto::clear_has_local_size() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EdgeProto::clear_local_size() {
  local_size_ = 0;
  clear_has_local_size();
}
inline ::google::protobuf::int32 EdgeProto::local_size() const {
  return local_size_;
}
inline void EdgeProto::set_local_size(::google::protobuf::int32 value) {
  set_has_local_size();
  local_size_ = value;
}

// optional .lapis.EdgeProto.PoolingMethod pooling_method = 15;
inline bool EdgeProto::has_pooling_method() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EdgeProto::set_has_pooling_method() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EdgeProto::clear_has_pooling_method() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EdgeProto::clear_pooling_method() {
  pooling_method_ = 1;
  clear_has_pooling_method();
}
inline ::lapis::EdgeProto_PoolingMethod EdgeProto::pooling_method() const {
  return static_cast< ::lapis::EdgeProto_PoolingMethod >(pooling_method_);
}
inline void EdgeProto::set_pooling_method(::lapis::EdgeProto_PoolingMethod value) {
  assert(::lapis::EdgeProto_PoolingMethod_IsValid(value));
  set_has_pooling_method();
  pooling_method_ = value;
}

// -------------------------------------------------------------------

// BlobProto

// -------------------------------------------------------------------

// LayerProto

// required string name = 1;
inline bool LayerProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LayerProto::name() const {
  return *name_;
}
inline void LayerProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LayerProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LayerProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LayerProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string type = 3;
inline bool LayerProto::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerProto::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerProto::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& LayerProto::type() const {
  return *type_;
}
inline void LayerProto::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void LayerProto::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void LayerProto::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerProto::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* LayerProto::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerProto::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string data_source = 7;
inline bool LayerProto::has_data_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerProto::set_has_data_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayerProto::clear_has_data_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayerProto::clear_data_source() {
  if (data_source_ != &::google::protobuf::internal::kEmptyString) {
    data_source_->clear();
  }
  clear_has_data_source();
}
inline const ::std::string& LayerProto::data_source() const {
  return *data_source_;
}
inline void LayerProto::set_data_source(const ::std::string& value) {
  set_has_data_source();
  if (data_source_ == &::google::protobuf::internal::kEmptyString) {
    data_source_ = new ::std::string;
  }
  data_source_->assign(value);
}
inline void LayerProto::set_data_source(const char* value) {
  set_has_data_source();
  if (data_source_ == &::google::protobuf::internal::kEmptyString) {
    data_source_ = new ::std::string;
  }
  data_source_->assign(value);
}
inline void LayerProto::set_data_source(const char* value, size_t size) {
  set_has_data_source();
  if (data_source_ == &::google::protobuf::internal::kEmptyString) {
    data_source_ = new ::std::string;
  }
  data_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerProto::mutable_data_source() {
  set_has_data_source();
  if (data_source_ == &::google::protobuf::internal::kEmptyString) {
    data_source_ = new ::std::string;
  }
  return data_source_;
}
inline ::std::string* LayerProto::release_data_source() {
  clear_has_data_source();
  if (data_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_source_;
    data_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerProto::set_allocated_data_source(::std::string* data_source) {
  if (data_source_ != &::google::protobuf::internal::kEmptyString) {
    delete data_source_;
  }
  if (data_source) {
    set_has_data_source();
    data_source_ = data_source;
  } else {
    clear_has_data_source();
    data_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float drop_prob = 8 [default = 0];
inline bool LayerProto::has_drop_prob() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayerProto::set_has_drop_prob() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LayerProto::clear_has_drop_prob() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LayerProto::clear_drop_prob() {
  drop_prob_ = 0;
  clear_has_drop_prob();
}
inline float LayerProto::drop_prob() const {
  return drop_prob_;
}
inline void LayerProto::set_drop_prob(float value) {
  set_has_drop_prob();
  drop_prob_ = value;
}

// -------------------------------------------------------------------

// NetProto

// repeated .lapis.LayerProto layer = 3;
inline int NetProto::layer_size() const {
  return layer_.size();
}
inline void NetProto::clear_layer() {
  layer_.Clear();
}
inline const ::lapis::LayerProto& NetProto::layer(int index) const {
  return layer_.Get(index);
}
inline ::lapis::LayerProto* NetProto::mutable_layer(int index) {
  return layer_.Mutable(index);
}
inline ::lapis::LayerProto* NetProto::add_layer() {
  return layer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::LayerProto >&
NetProto::layer() const {
  return layer_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::LayerProto >*
NetProto::mutable_layer() {
  return &layer_;
}

// repeated .lapis.EdgeProto edge = 4;
inline int NetProto::edge_size() const {
  return edge_.size();
}
inline void NetProto::clear_edge() {
  edge_.Clear();
}
inline const ::lapis::EdgeProto& NetProto::edge(int index) const {
  return edge_.Get(index);
}
inline ::lapis::EdgeProto* NetProto::mutable_edge(int index) {
  return edge_.Mutable(index);
}
inline ::lapis::EdgeProto* NetProto::add_edge() {
  return edge_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::EdgeProto >&
NetProto::edge() const {
  return edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::EdgeProto >*
NetProto::mutable_edge() {
  return &edge_;
}

// -------------------------------------------------------------------

// SGDProto

// required float base_learning_rate = 1;
inline bool SGDProto::has_base_learning_rate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SGDProto::set_has_base_learning_rate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SGDProto::clear_has_base_learning_rate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SGDProto::clear_base_learning_rate() {
  base_learning_rate_ = 0;
  clear_has_base_learning_rate();
}
inline float SGDProto::base_learning_rate() const {
  return base_learning_rate_;
}
inline void SGDProto::set_base_learning_rate(float value) {
  set_has_base_learning_rate();
  base_learning_rate_ = value;
}

// optional float base_momentum = 2 [default = 0];
inline bool SGDProto::has_base_momentum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SGDProto::set_has_base_momentum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SGDProto::clear_has_base_momentum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SGDProto::clear_base_momentum() {
  base_momentum_ = 0;
  clear_has_base_momentum();
}
inline float SGDProto::base_momentum() const {
  return base_momentum_;
}
inline void SGDProto::set_base_momentum(float value) {
  set_has_base_momentum();
  base_momentum_ = value;
}

// optional float base_weight_decay = 3 [default = 0];
inline bool SGDProto::has_base_weight_decay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SGDProto::set_has_base_weight_decay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SGDProto::clear_has_base_weight_decay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SGDProto::clear_base_weight_decay() {
  base_weight_decay_ = 0;
  clear_has_base_weight_decay();
}
inline float SGDProto::base_weight_decay() const {
  return base_weight_decay_;
}
inline void SGDProto::set_base_weight_decay(float value) {
  set_has_base_weight_decay();
  base_weight_decay_ = value;
}

// optional float momentum_x = 4;
inline bool SGDProto::has_momentum_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SGDProto::set_has_momentum_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SGDProto::clear_has_momentum_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SGDProto::clear_momentum_x() {
  momentum_x_ = 0;
  clear_has_momentum_x();
}
inline float SGDProto::momentum_x() const {
  return momentum_x_;
}
inline void SGDProto::set_momentum_x(float value) {
  set_has_momentum_x();
  momentum_x_ = value;
}

// optional float learning_rate_x = 5;
inline bool SGDProto::has_learning_rate_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SGDProto::set_has_learning_rate_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SGDProto::clear_has_learning_rate_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SGDProto::clear_learning_rate_x() {
  learning_rate_x_ = 0;
  clear_has_learning_rate_x();
}
inline float SGDProto::learning_rate_x() const {
  return learning_rate_x_;
}
inline void SGDProto::set_learning_rate_x(float value) {
  set_has_learning_rate_x();
  learning_rate_x_ = value;
}

// optional float weight_decay_x = 6;
inline bool SGDProto::has_weight_decay_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SGDProto::set_has_weight_decay_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SGDProto::clear_has_weight_decay_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SGDProto::clear_weight_decay_x() {
  weight_decay_x_ = 0;
  clear_has_weight_decay_x();
}
inline float SGDProto::weight_decay_x() const {
  return weight_decay_x_;
}
inline void SGDProto::set_weight_decay_x(float value) {
  set_has_weight_decay_x();
  weight_decay_x_ = value;
}

// optional int32 learning_rate_change_steps = 7;
inline bool SGDProto::has_learning_rate_change_steps() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SGDProto::set_has_learning_rate_change_steps() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SGDProto::clear_has_learning_rate_change_steps() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SGDProto::clear_learning_rate_change_steps() {
  learning_rate_change_steps_ = 0;
  clear_has_learning_rate_change_steps();
}
inline ::google::protobuf::int32 SGDProto::learning_rate_change_steps() const {
  return learning_rate_change_steps_;
}
inline void SGDProto::set_learning_rate_change_steps(::google::protobuf::int32 value) {
  set_has_learning_rate_change_steps();
  learning_rate_change_steps_ = value;
}

// optional int32 momentum_change_steps = 8;
inline bool SGDProto::has_momentum_change_steps() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SGDProto::set_has_momentum_change_steps() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SGDProto::clear_has_momentum_change_steps() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SGDProto::clear_momentum_change_steps() {
  momentum_change_steps_ = 0;
  clear_has_momentum_change_steps();
}
inline ::google::protobuf::int32 SGDProto::momentum_change_steps() const {
  return momentum_change_steps_;
}
inline void SGDProto::set_momentum_change_steps(::google::protobuf::int32 value) {
  set_has_momentum_change_steps();
  momentum_change_steps_ = value;
}

// optional int32 weight_decay_change_steps = 9;
inline bool SGDProto::has_weight_decay_change_steps() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SGDProto::set_has_weight_decay_change_steps() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SGDProto::clear_has_weight_decay_change_steps() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SGDProto::clear_weight_decay_change_steps() {
  weight_decay_change_steps_ = 0;
  clear_has_weight_decay_change_steps();
}
inline ::google::protobuf::int32 SGDProto::weight_decay_change_steps() const {
  return weight_decay_change_steps_;
}
inline void SGDProto::set_weight_decay_change_steps(::google::protobuf::int32 value) {
  set_has_weight_decay_change_steps();
  weight_decay_change_steps_ = value;
}

// optional .lapis.SGDProto.ChangeProto learning_rate_change = 10 [default = kInverse_t];
inline bool SGDProto::has_learning_rate_change() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SGDProto::set_has_learning_rate_change() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SGDProto::clear_has_learning_rate_change() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SGDProto::clear_learning_rate_change() {
  learning_rate_change_ = 1;
  clear_has_learning_rate_change();
}
inline ::lapis::SGDProto_ChangeProto SGDProto::learning_rate_change() const {
  return static_cast< ::lapis::SGDProto_ChangeProto >(learning_rate_change_);
}
inline void SGDProto::set_learning_rate_change(::lapis::SGDProto_ChangeProto value) {
  assert(::lapis::SGDProto_ChangeProto_IsValid(value));
  set_has_learning_rate_change();
  learning_rate_change_ = value;
}

// optional .lapis.SGDProto.ChangeProto weight_decay_change = 11 [default = kFixed];
inline bool SGDProto::has_weight_decay_change() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SGDProto::set_has_weight_decay_change() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SGDProto::clear_has_weight_decay_change() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SGDProto::clear_weight_decay_change() {
  weight_decay_change_ = 0;
  clear_has_weight_decay_change();
}
inline ::lapis::SGDProto_ChangeProto SGDProto::weight_decay_change() const {
  return static_cast< ::lapis::SGDProto_ChangeProto >(weight_decay_change_);
}
inline void SGDProto::set_weight_decay_change(::lapis::SGDProto_ChangeProto value) {
  assert(::lapis::SGDProto_ChangeProto_IsValid(value));
  set_has_weight_decay_change();
  weight_decay_change_ = value;
}

// optional .lapis.SGDProto.ChangeProto momentum_change = 12 [default = kFixed];
inline bool SGDProto::has_momentum_change() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SGDProto::set_has_momentum_change() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SGDProto::clear_has_momentum_change() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SGDProto::clear_momentum_change() {
  momentum_change_ = 0;
  clear_has_momentum_change();
}
inline ::lapis::SGDProto_ChangeProto SGDProto::momentum_change() const {
  return static_cast< ::lapis::SGDProto_ChangeProto >(momentum_change_);
}
inline void SGDProto::set_momentum_change(::lapis::SGDProto_ChangeProto value) {
  assert(::lapis::SGDProto_ChangeProto_IsValid(value));
  set_has_momentum_change();
  momentum_change_ = value;
}

// optional int32 total_steps = 13;
inline bool SGDProto::has_total_steps() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SGDProto::set_has_total_steps() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SGDProto::clear_has_total_steps() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SGDProto::clear_total_steps() {
  total_steps_ = 0;
  clear_has_total_steps();
}
inline ::google::protobuf::int32 SGDProto::total_steps() const {
  return total_steps_;
}
inline void SGDProto::set_total_steps(::google::protobuf::int32 value) {
  set_has_total_steps();
  total_steps_ = value;
}

// optional int32 train_batchsize = 14;
inline bool SGDProto::has_train_batchsize() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SGDProto::set_has_train_batchsize() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SGDProto::clear_has_train_batchsize() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SGDProto::clear_train_batchsize() {
  train_batchsize_ = 0;
  clear_has_train_batchsize();
}
inline ::google::protobuf::int32 SGDProto::train_batchsize() const {
  return train_batchsize_;
}
inline void SGDProto::set_train_batchsize(::google::protobuf::int32 value) {
  set_has_train_batchsize();
  train_batchsize_ = value;
}

// optional int32 validation_batchsize = 15;
inline bool SGDProto::has_validation_batchsize() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SGDProto::set_has_validation_batchsize() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SGDProto::clear_has_validation_batchsize() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SGDProto::clear_validation_batchsize() {
  validation_batchsize_ = 0;
  clear_has_validation_batchsize();
}
inline ::google::protobuf::int32 SGDProto::validation_batchsize() const {
  return validation_batchsize_;
}
inline void SGDProto::set_validation_batchsize(::google::protobuf::int32 value) {
  set_has_validation_batchsize();
  validation_batchsize_ = value;
}

// optional int32 test_batchsize = 16;
inline bool SGDProto::has_test_batchsize() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SGDProto::set_has_test_batchsize() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SGDProto::clear_has_test_batchsize() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SGDProto::clear_test_batchsize() {
  test_batchsize_ = 0;
  clear_has_test_batchsize();
}
inline ::google::protobuf::int32 SGDProto::test_batchsize() const {
  return test_batchsize_;
}
inline void SGDProto::set_test_batchsize(::google::protobuf::int32 value) {
  set_has_test_batchsize();
  test_batchsize_ = value;
}

// -------------------------------------------------------------------

// PerformanceProto

// optional float precision = 1;
inline bool PerformanceProto::has_precision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerformanceProto::set_has_precision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerformanceProto::clear_has_precision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerformanceProto::clear_precision() {
  precision_ = 0;
  clear_has_precision();
}
inline float PerformanceProto::precision() const {
  return precision_;
}
inline void PerformanceProto::set_precision(float value) {
  set_has_precision();
  precision_ = value;
}

// optional float recall = 2;
inline bool PerformanceProto::has_recall() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerformanceProto::set_has_recall() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerformanceProto::clear_has_recall() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerformanceProto::clear_recall() {
  recall_ = 0;
  clear_has_recall();
}
inline float PerformanceProto::recall() const {
  return recall_;
}
inline void PerformanceProto::set_recall(float value) {
  set_has_recall();
  recall_ = value;
}

// optional float map = 3;
inline bool PerformanceProto::has_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerformanceProto::set_has_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerformanceProto::clear_has_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PerformanceProto::clear_map() {
  map_ = 0;
  clear_has_map();
}
inline float PerformanceProto::map() const {
  return map_;
}
inline void PerformanceProto::set_map(float value) {
  set_has_map();
  map_ = value;
}

// optional float precision50 = 4;
inline bool PerformanceProto::has_precision50() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PerformanceProto::set_has_precision50() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PerformanceProto::clear_has_precision50() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PerformanceProto::clear_precision50() {
  precision50_ = 0;
  clear_has_precision50();
}
inline float PerformanceProto::precision50() const {
  return precision50_;
}
inline void PerformanceProto::set_precision50(float value) {
  set_has_precision50();
  precision50_ = value;
}

// -------------------------------------------------------------------

// TrainerProto

// optional .lapis.SGDProto sgd = 1;
inline bool TrainerProto::has_sgd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrainerProto::set_has_sgd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrainerProto::clear_has_sgd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrainerProto::clear_sgd() {
  if (sgd_ != NULL) sgd_->::lapis::SGDProto::Clear();
  clear_has_sgd();
}
inline const ::lapis::SGDProto& TrainerProto::sgd() const {
  return sgd_ != NULL ? *sgd_ : *default_instance_->sgd_;
}
inline ::lapis::SGDProto* TrainerProto::mutable_sgd() {
  set_has_sgd();
  if (sgd_ == NULL) sgd_ = new ::lapis::SGDProto;
  return sgd_;
}
inline ::lapis::SGDProto* TrainerProto::release_sgd() {
  clear_has_sgd();
  ::lapis::SGDProto* temp = sgd_;
  sgd_ = NULL;
  return temp;
}
inline void TrainerProto::set_allocated_sgd(::lapis::SGDProto* sgd) {
  delete sgd_;
  sgd_ = sgd;
  if (sgd) {
    set_has_sgd();
  } else {
    clear_has_sgd();
  }
}

// optional int32 checkpoint_after_steps = 2 [default = 0];
inline bool TrainerProto::has_checkpoint_after_steps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrainerProto::set_has_checkpoint_after_steps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrainerProto::clear_has_checkpoint_after_steps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrainerProto::clear_checkpoint_after_steps() {
  checkpoint_after_steps_ = 0;
  clear_has_checkpoint_after_steps();
}
inline ::google::protobuf::int32 TrainerProto::checkpoint_after_steps() const {
  return checkpoint_after_steps_;
}
inline void TrainerProto::set_checkpoint_after_steps(::google::protobuf::int32 value) {
  set_has_checkpoint_after_steps();
  checkpoint_after_steps_ = value;
}

// optional int32 checkpoint_every_steps = 3 [default = 0];
inline bool TrainerProto::has_checkpoint_every_steps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrainerProto::set_has_checkpoint_every_steps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrainerProto::clear_has_checkpoint_every_steps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrainerProto::clear_checkpoint_every_steps() {
  checkpoint_every_steps_ = 0;
  clear_has_checkpoint_every_steps();
}
inline ::google::protobuf::int32 TrainerProto::checkpoint_every_steps() const {
  return checkpoint_every_steps_;
}
inline void TrainerProto::set_checkpoint_every_steps(::google::protobuf::int32 value) {
  set_has_checkpoint_every_steps();
  checkpoint_every_steps_ = value;
}

// optional string checkpoint_prefix = 4 [default = "tmp/checkpoint"];
inline bool TrainerProto::has_checkpoint_prefix() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrainerProto::set_has_checkpoint_prefix() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrainerProto::clear_has_checkpoint_prefix() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrainerProto::clear_checkpoint_prefix() {
  if (checkpoint_prefix_ != _default_checkpoint_prefix_) {
    checkpoint_prefix_->assign(*_default_checkpoint_prefix_);
  }
  clear_has_checkpoint_prefix();
}
inline const ::std::string& TrainerProto::checkpoint_prefix() const {
  return *checkpoint_prefix_;
}
inline void TrainerProto::set_checkpoint_prefix(const ::std::string& value) {
  set_has_checkpoint_prefix();
  if (checkpoint_prefix_ == _default_checkpoint_prefix_) {
    checkpoint_prefix_ = new ::std::string;
  }
  checkpoint_prefix_->assign(value);
}
inline void TrainerProto::set_checkpoint_prefix(const char* value) {
  set_has_checkpoint_prefix();
  if (checkpoint_prefix_ == _default_checkpoint_prefix_) {
    checkpoint_prefix_ = new ::std::string;
  }
  checkpoint_prefix_->assign(value);
}
inline void TrainerProto::set_checkpoint_prefix(const char* value, size_t size) {
  set_has_checkpoint_prefix();
  if (checkpoint_prefix_ == _default_checkpoint_prefix_) {
    checkpoint_prefix_ = new ::std::string;
  }
  checkpoint_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrainerProto::mutable_checkpoint_prefix() {
  set_has_checkpoint_prefix();
  if (checkpoint_prefix_ == _default_checkpoint_prefix_) {
    checkpoint_prefix_ = new ::std::string(*_default_checkpoint_prefix_);
  }
  return checkpoint_prefix_;
}
inline ::std::string* TrainerProto::release_checkpoint_prefix() {
  clear_has_checkpoint_prefix();
  if (checkpoint_prefix_ == _default_checkpoint_prefix_) {
    return NULL;
  } else {
    ::std::string* temp = checkpoint_prefix_;
    checkpoint_prefix_ = const_cast< ::std::string*>(_default_checkpoint_prefix_);
    return temp;
  }
}
inline void TrainerProto::set_allocated_checkpoint_prefix(::std::string* checkpoint_prefix) {
  if (checkpoint_prefix_ != _default_checkpoint_prefix_) {
    delete checkpoint_prefix_;
  }
  if (checkpoint_prefix) {
    set_has_checkpoint_prefix();
    checkpoint_prefix_ = checkpoint_prefix;
  } else {
    clear_has_checkpoint_prefix();
    checkpoint_prefix_ = const_cast< ::std::string*>(_default_checkpoint_prefix_);
  }
}

// optional int32 checkpoint_step = 5 [default = 0];
inline bool TrainerProto::has_checkpoint_step() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrainerProto::set_has_checkpoint_step() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrainerProto::clear_has_checkpoint_step() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrainerProto::clear_checkpoint_step() {
  checkpoint_step_ = 0;
  clear_has_checkpoint_step();
}
inline ::google::protobuf::int32 TrainerProto::checkpoint_step() const {
  return checkpoint_step_;
}
inline void TrainerProto::set_checkpoint_step(::google::protobuf::int32 value) {
  set_has_checkpoint_step();
  checkpoint_step_ = value;
}

// optional int32 display_after_steps = 6 [default = 0];
inline bool TrainerProto::has_display_after_steps() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrainerProto::set_has_display_after_steps() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrainerProto::clear_has_display_after_steps() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrainerProto::clear_display_after_steps() {
  display_after_steps_ = 0;
  clear_has_display_after_steps();
}
inline ::google::protobuf::int32 TrainerProto::display_after_steps() const {
  return display_after_steps_;
}
inline void TrainerProto::set_display_after_steps(::google::protobuf::int32 value) {
  set_has_display_after_steps();
  display_after_steps_ = value;
}

// optional int32 display_every_steps = 7 [default = 0];
inline bool TrainerProto::has_display_every_steps() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrainerProto::set_has_display_every_steps() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrainerProto::clear_has_display_every_steps() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrainerProto::clear_display_every_steps() {
  display_every_steps_ = 0;
  clear_has_display_every_steps();
}
inline ::google::protobuf::int32 TrainerProto::display_every_steps() const {
  return display_every_steps_;
}
inline void TrainerProto::set_display_every_steps(::google::protobuf::int32 value) {
  set_has_display_every_steps();
  display_every_steps_ = value;
}

// optional string display_prefix = 8 [default = "tmp/display"];
inline bool TrainerProto::has_display_prefix() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrainerProto::set_has_display_prefix() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrainerProto::clear_has_display_prefix() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrainerProto::clear_display_prefix() {
  if (display_prefix_ != _default_display_prefix_) {
    display_prefix_->assign(*_default_display_prefix_);
  }
  clear_has_display_prefix();
}
inline const ::std::string& TrainerProto::display_prefix() const {
  return *display_prefix_;
}
inline void TrainerProto::set_display_prefix(const ::std::string& value) {
  set_has_display_prefix();
  if (display_prefix_ == _default_display_prefix_) {
    display_prefix_ = new ::std::string;
  }
  display_prefix_->assign(value);
}
inline void TrainerProto::set_display_prefix(const char* value) {
  set_has_display_prefix();
  if (display_prefix_ == _default_display_prefix_) {
    display_prefix_ = new ::std::string;
  }
  display_prefix_->assign(value);
}
inline void TrainerProto::set_display_prefix(const char* value, size_t size) {
  set_has_display_prefix();
  if (display_prefix_ == _default_display_prefix_) {
    display_prefix_ = new ::std::string;
  }
  display_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrainerProto::mutable_display_prefix() {
  set_has_display_prefix();
  if (display_prefix_ == _default_display_prefix_) {
    display_prefix_ = new ::std::string(*_default_display_prefix_);
  }
  return display_prefix_;
}
inline ::std::string* TrainerProto::release_display_prefix() {
  clear_has_display_prefix();
  if (display_prefix_ == _default_display_prefix_) {
    return NULL;
  } else {
    ::std::string* temp = display_prefix_;
    display_prefix_ = const_cast< ::std::string*>(_default_display_prefix_);
    return temp;
  }
}
inline void TrainerProto::set_allocated_display_prefix(::std::string* display_prefix) {
  if (display_prefix_ != _default_display_prefix_) {
    delete display_prefix_;
  }
  if (display_prefix) {
    set_has_display_prefix();
    display_prefix_ = display_prefix;
  } else {
    clear_has_display_prefix();
    display_prefix_ = const_cast< ::std::string*>(_default_display_prefix_);
  }
}

// optional int32 validate_step = 9 [default = 0];
inline bool TrainerProto::has_validate_step() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TrainerProto::set_has_validate_step() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TrainerProto::clear_has_validate_step() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TrainerProto::clear_validate_step() {
  validate_step_ = 0;
  clear_has_validate_step();
}
inline ::google::protobuf::int32 TrainerProto::validate_step() const {
  return validate_step_;
}
inline void TrainerProto::set_validate_step(::google::protobuf::int32 value) {
  set_has_validate_step();
  validate_step_ = value;
}

// optional int32 validate_after_steps = 10 [default = 0];
inline bool TrainerProto::has_validate_after_steps() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TrainerProto::set_has_validate_after_steps() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TrainerProto::clear_has_validate_after_steps() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TrainerProto::clear_validate_after_steps() {
  validate_after_steps_ = 0;
  clear_has_validate_after_steps();
}
inline ::google::protobuf::int32 TrainerProto::validate_after_steps() const {
  return validate_after_steps_;
}
inline void TrainerProto::set_validate_after_steps(::google::protobuf::int32 value) {
  set_has_validate_after_steps();
  validate_after_steps_ = value;
}

// optional int32 validate_every_steps = 11 [default = 0];
inline bool TrainerProto::has_validate_every_steps() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TrainerProto::set_has_validate_every_steps() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TrainerProto::clear_has_validate_every_steps() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TrainerProto::clear_validate_every_steps() {
  validate_every_steps_ = 0;
  clear_has_validate_every_steps();
}
inline ::google::protobuf::int32 TrainerProto::validate_every_steps() const {
  return validate_every_steps_;
}
inline void TrainerProto::set_validate_every_steps(::google::protobuf::int32 value) {
  set_has_validate_every_steps();
  validate_every_steps_ = value;
}

// repeated .lapis.DataSourceProto train_data = 12;
inline int TrainerProto::train_data_size() const {
  return train_data_.size();
}
inline void TrainerProto::clear_train_data() {
  train_data_.Clear();
}
inline const ::lapis::DataSourceProto& TrainerProto::train_data(int index) const {
  return train_data_.Get(index);
}
inline ::lapis::DataSourceProto* TrainerProto::mutable_train_data(int index) {
  return train_data_.Mutable(index);
}
inline ::lapis::DataSourceProto* TrainerProto::add_train_data() {
  return train_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >&
TrainerProto::train_data() const {
  return train_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >*
TrainerProto::mutable_train_data() {
  return &train_data_;
}

// repeated .lapis.DataSourceProto validation_data = 13;
inline int TrainerProto::validation_data_size() const {
  return validation_data_.size();
}
inline void TrainerProto::clear_validation_data() {
  validation_data_.Clear();
}
inline const ::lapis::DataSourceProto& TrainerProto::validation_data(int index) const {
  return validation_data_.Get(index);
}
inline ::lapis::DataSourceProto* TrainerProto::mutable_validation_data(int index) {
  return validation_data_.Mutable(index);
}
inline ::lapis::DataSourceProto* TrainerProto::add_validation_data() {
  return validation_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >&
TrainerProto::validation_data() const {
  return validation_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >*
TrainerProto::mutable_validation_data() {
  return &validation_data_;
}

// repeated .lapis.DataSourceProto test_data = 14;
inline int TrainerProto::test_data_size() const {
  return test_data_.size();
}
inline void TrainerProto::clear_test_data() {
  test_data_.Clear();
}
inline const ::lapis::DataSourceProto& TrainerProto::test_data(int index) const {
  return test_data_.Get(index);
}
inline ::lapis::DataSourceProto* TrainerProto::mutable_test_data(int index) {
  return test_data_.Mutable(index);
}
inline ::lapis::DataSourceProto* TrainerProto::add_test_data() {
  return test_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >&
TrainerProto::test_data() const {
  return test_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::DataSourceProto >*
TrainerProto::mutable_test_data() {
  return &test_data_;
}

// optional string perf_prefix = 15 [default = "tmp/performance"];
inline bool TrainerProto::has_perf_prefix() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TrainerProto::set_has_perf_prefix() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TrainerProto::clear_has_perf_prefix() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TrainerProto::clear_perf_prefix() {
  if (perf_prefix_ != _default_perf_prefix_) {
    perf_prefix_->assign(*_default_perf_prefix_);
  }
  clear_has_perf_prefix();
}
inline const ::std::string& TrainerProto::perf_prefix() const {
  return *perf_prefix_;
}
inline void TrainerProto::set_perf_prefix(const ::std::string& value) {
  set_has_perf_prefix();
  if (perf_prefix_ == _default_perf_prefix_) {
    perf_prefix_ = new ::std::string;
  }
  perf_prefix_->assign(value);
}
inline void TrainerProto::set_perf_prefix(const char* value) {
  set_has_perf_prefix();
  if (perf_prefix_ == _default_perf_prefix_) {
    perf_prefix_ = new ::std::string;
  }
  perf_prefix_->assign(value);
}
inline void TrainerProto::set_perf_prefix(const char* value, size_t size) {
  set_has_perf_prefix();
  if (perf_prefix_ == _default_perf_prefix_) {
    perf_prefix_ = new ::std::string;
  }
  perf_prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrainerProto::mutable_perf_prefix() {
  set_has_perf_prefix();
  if (perf_prefix_ == _default_perf_prefix_) {
    perf_prefix_ = new ::std::string(*_default_perf_prefix_);
  }
  return perf_prefix_;
}
inline ::std::string* TrainerProto::release_perf_prefix() {
  clear_has_perf_prefix();
  if (perf_prefix_ == _default_perf_prefix_) {
    return NULL;
  } else {
    ::std::string* temp = perf_prefix_;
    perf_prefix_ = const_cast< ::std::string*>(_default_perf_prefix_);
    return temp;
  }
}
inline void TrainerProto::set_allocated_perf_prefix(::std::string* perf_prefix) {
  if (perf_prefix_ != _default_perf_prefix_) {
    delete perf_prefix_;
  }
  if (perf_prefix) {
    set_has_perf_prefix();
    perf_prefix_ = perf_prefix;
  } else {
    clear_has_perf_prefix();
    perf_prefix_ = const_cast< ::std::string*>(_default_perf_prefix_);
  }
}

// optional .lapis.TrainerProto.Algorithm alg = 16 [default = kBackPropagation];
inline bool TrainerProto::has_alg() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TrainerProto::set_has_alg() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TrainerProto::clear_has_alg() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TrainerProto::clear_alg() {
  alg_ = 1;
  clear_has_alg();
}
inline ::lapis::TrainerProto_Algorithm TrainerProto::alg() const {
  return static_cast< ::lapis::TrainerProto_Algorithm >(alg_);
}
inline void TrainerProto::set_alg(::lapis::TrainerProto_Algorithm value) {
  assert(::lapis::TrainerProto_Algorithm_IsValid(value));
  set_has_alg();
  alg_ = value;
}

// optional bool do_train = 17 [default = true];
inline bool TrainerProto::has_do_train() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TrainerProto::set_has_do_train() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TrainerProto::clear_has_do_train() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TrainerProto::clear_do_train() {
  do_train_ = true;
  clear_has_do_train();
}
inline bool TrainerProto::do_train() const {
  return do_train_;
}
inline void TrainerProto::set_do_train(bool value) {
  set_has_do_train();
  do_train_ = value;
}

// optional bool do_test = 18 [default = false];
inline bool TrainerProto::has_do_test() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TrainerProto::set_has_do_test() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TrainerProto::clear_has_do_test() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TrainerProto::clear_do_test() {
  do_test_ = false;
  clear_has_do_test();
}
inline bool TrainerProto::do_test() const {
  return do_test_;
}
inline void TrainerProto::set_do_test(bool value) {
  set_has_do_test();
  do_test_ = value;
}

// -------------------------------------------------------------------

// ModelProto

// optional string name = 1;
inline bool ModelProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelProto::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ModelProto::name() const {
  return *name_;
}
inline void ModelProto::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelProto::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelProto::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelProto::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ModelProto::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModelProto::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .lapis.NetProto net = 2;
inline bool ModelProto::has_net() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelProto::set_has_net() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelProto::clear_has_net() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelProto::clear_net() {
  if (net_ != NULL) net_->::lapis::NetProto::Clear();
  clear_has_net();
}
inline const ::lapis::NetProto& ModelProto::net() const {
  return net_ != NULL ? *net_ : *default_instance_->net_;
}
inline ::lapis::NetProto* ModelProto::mutable_net() {
  set_has_net();
  if (net_ == NULL) net_ = new ::lapis::NetProto;
  return net_;
}
inline ::lapis::NetProto* ModelProto::release_net() {
  clear_has_net();
  ::lapis::NetProto* temp = net_;
  net_ = NULL;
  return temp;
}
inline void ModelProto::set_allocated_net(::lapis::NetProto* net) {
  delete net_;
  net_ = net;
  if (net) {
    set_has_net();
  } else {
    clear_has_net();
  }
}

// required .lapis.TrainerProto trainer = 3;
inline bool ModelProto::has_trainer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelProto::set_has_trainer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelProto::clear_has_trainer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelProto::clear_trainer() {
  if (trainer_ != NULL) trainer_->::lapis::TrainerProto::Clear();
  clear_has_trainer();
}
inline const ::lapis::TrainerProto& ModelProto::trainer() const {
  return trainer_ != NULL ? *trainer_ : *default_instance_->trainer_;
}
inline ::lapis::TrainerProto* ModelProto::mutable_trainer() {
  set_has_trainer();
  if (trainer_ == NULL) trainer_ = new ::lapis::TrainerProto;
  return trainer_;
}
inline ::lapis::TrainerProto* ModelProto::release_trainer() {
  clear_has_trainer();
  ::lapis::TrainerProto* temp = trainer_;
  trainer_ = NULL;
  return temp;
}
inline void ModelProto::set_allocated_trainer(::lapis::TrainerProto* trainer) {
  delete trainer_;
  trainer_ = trainer;
  if (trainer) {
    set_has_trainer();
  } else {
    clear_has_trainer();
  }
}

// -------------------------------------------------------------------

// float_vector_message

// repeated float myfloat = 1;
inline int float_vector_message::myfloat_size() const {
  return myfloat_.size();
}
inline void float_vector_message::clear_myfloat() {
  myfloat_.Clear();
}
inline float float_vector_message::myfloat(int index) const {
  return myfloat_.Get(index);
}
inline void float_vector_message::set_myfloat(int index, float value) {
  myfloat_.Set(index, value);
}
inline void float_vector_message::add_myfloat(float value) {
  myfloat_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
float_vector_message::myfloat() const {
  return myfloat_;
}
inline ::google::protobuf::RepeatedField< float >*
float_vector_message::mutable_myfloat() {
  return &myfloat_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace lapis

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lapis::ParamProto_InitMethod>() {
  return ::lapis::ParamProto_InitMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lapis::EdgeProto_PoolingMethod>() {
  return ::lapis::EdgeProto_PoolingMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lapis::SGDProto_ChangeProto>() {
  return ::lapis::SGDProto_ChangeProto_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lapis::TrainerProto_Algorithm>() {
  return ::lapis::TrainerProto_Algorithm_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_model_2eproto__INCLUDED
