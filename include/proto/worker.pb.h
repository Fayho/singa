// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: worker.proto

#ifndef PROTOBUF_worker_2eproto__INCLUDED
#define PROTOBUF_worker_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace lapis {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_worker_2eproto();
void protobuf_AssignDesc_worker_2eproto();
void protobuf_ShutdownFile_worker_2eproto();

class RegisterWorkerRequest;
class ShardAssignment;
class ShardAssignmentRequest;
class ShardInfo;
class MethodStats;
class HashGet;
class TableData;
class DiskData;
class FlushDiskTable;

// ===================================================================

class RegisterWorkerRequest : public ::google::protobuf::Message {
 public:
  RegisterWorkerRequest();
  virtual ~RegisterWorkerRequest();

  RegisterWorkerRequest(const RegisterWorkerRequest& from);

  inline RegisterWorkerRequest& operator=(const RegisterWorkerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterWorkerRequest& default_instance();

  void Swap(RegisterWorkerRequest* other);

  // implements Message ----------------------------------------------

  RegisterWorkerRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterWorkerRequest& from);
  void MergeFrom(const RegisterWorkerRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lapis.RegisterWorkerRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_worker_2eproto();
  friend void protobuf_AssignDesc_worker_2eproto();
  friend void protobuf_ShutdownFile_worker_2eproto();

  void InitAsDefaultInstance();
  static RegisterWorkerRequest* default_instance_;
};
// -------------------------------------------------------------------

class ShardAssignment : public ::google::protobuf::Message {
 public:
  ShardAssignment();
  virtual ~ShardAssignment();

  ShardAssignment(const ShardAssignment& from);

  inline ShardAssignment& operator=(const ShardAssignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShardAssignment& default_instance();

  void Swap(ShardAssignment* other);

  // implements Message ----------------------------------------------

  ShardAssignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShardAssignment& from);
  void MergeFrom(const ShardAssignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline ::google::protobuf::int32 table() const;
  inline void set_table(::google::protobuf::int32 value);

  // required int32 shard = 2;
  inline bool has_shard() const;
  inline void clear_shard();
  static const int kShardFieldNumber = 2;
  inline ::google::protobuf::int32 shard() const;
  inline void set_shard(::google::protobuf::int32 value);

  // required int32 new_worker = 4;
  inline bool has_new_worker() const;
  inline void clear_new_worker();
  static const int kNewWorkerFieldNumber = 4;
  inline ::google::protobuf::int32 new_worker() const;
  inline void set_new_worker(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lapis.ShardAssignment)
 private:
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_shard();
  inline void clear_has_shard();
  inline void set_has_new_worker();
  inline void clear_has_new_worker();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 table_;
  ::google::protobuf::int32 shard_;
  ::google::protobuf::int32 new_worker_;
  friend void  protobuf_AddDesc_worker_2eproto();
  friend void protobuf_AssignDesc_worker_2eproto();
  friend void protobuf_ShutdownFile_worker_2eproto();

  void InitAsDefaultInstance();
  static ShardAssignment* default_instance_;
};
// -------------------------------------------------------------------

class ShardAssignmentRequest : public ::google::protobuf::Message {
 public:
  ShardAssignmentRequest();
  virtual ~ShardAssignmentRequest();

  ShardAssignmentRequest(const ShardAssignmentRequest& from);

  inline ShardAssignmentRequest& operator=(const ShardAssignmentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShardAssignmentRequest& default_instance();

  void Swap(ShardAssignmentRequest* other);

  // implements Message ----------------------------------------------

  ShardAssignmentRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShardAssignmentRequest& from);
  void MergeFrom(const ShardAssignmentRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lapis.ShardAssignment assign = 1;
  inline int assign_size() const;
  inline void clear_assign();
  static const int kAssignFieldNumber = 1;
  inline const ::lapis::ShardAssignment& assign(int index) const;
  inline ::lapis::ShardAssignment* mutable_assign(int index);
  inline ::lapis::ShardAssignment* add_assign();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::ShardAssignment >&
      assign() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::ShardAssignment >*
      mutable_assign();

  // @@protoc_insertion_point(class_scope:lapis.ShardAssignmentRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::lapis::ShardAssignment > assign_;
  friend void  protobuf_AddDesc_worker_2eproto();
  friend void protobuf_AssignDesc_worker_2eproto();
  friend void protobuf_ShutdownFile_worker_2eproto();

  void InitAsDefaultInstance();
  static ShardAssignmentRequest* default_instance_;
};
// -------------------------------------------------------------------

class ShardInfo : public ::google::protobuf::Message {
 public:
  ShardInfo();
  virtual ~ShardInfo();

  ShardInfo(const ShardInfo& from);

  inline ShardInfo& operator=(const ShardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShardInfo& default_instance();

  void Swap(ShardInfo* other);

  // implements Message ----------------------------------------------

  ShardInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShardInfo& from);
  void MergeFrom(const ShardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline ::google::protobuf::uint32 table() const;
  inline void set_table(::google::protobuf::uint32 value);

  // required uint32 shard = 2;
  inline bool has_shard() const;
  inline void clear_shard();
  static const int kShardFieldNumber = 2;
  inline ::google::protobuf::uint32 shard() const;
  inline void set_shard(::google::protobuf::uint32 value);

  // required uint64 entries = 3;
  inline bool has_entries() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 3;
  inline ::google::protobuf::uint64 entries() const;
  inline void set_entries(::google::protobuf::uint64 value);

  // required uint32 owner = 4;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 4;
  inline ::google::protobuf::uint32 owner() const;
  inline void set_owner(::google::protobuf::uint32 value);

  // required int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lapis.ShardInfo)
 private:
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_shard();
  inline void clear_has_shard();
  inline void set_has_entries();
  inline void clear_has_entries();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 table_;
  ::google::protobuf::uint32 shard_;
  ::google::protobuf::uint64 entries_;
  ::google::protobuf::uint32 owner_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_worker_2eproto();
  friend void protobuf_AssignDesc_worker_2eproto();
  friend void protobuf_ShutdownFile_worker_2eproto();

  void InitAsDefaultInstance();
  static ShardInfo* default_instance_;
};
// -------------------------------------------------------------------

class MethodStats : public ::google::protobuf::Message {
 public:
  MethodStats();
  virtual ~MethodStats();

  MethodStats(const MethodStats& from);

  inline MethodStats& operator=(const MethodStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MethodStats& default_instance();

  void Swap(MethodStats* other);

  // implements Message ----------------------------------------------

  MethodStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MethodStats& from);
  void MergeFrom(const MethodStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double total_time = 1;
  inline bool has_total_time() const;
  inline void clear_total_time();
  static const int kTotalTimeFieldNumber = 1;
  inline double total_time() const;
  inline void set_total_time(double value);

  // required double shard_time = 2;
  inline bool has_shard_time() const;
  inline void clear_shard_time();
  static const int kShardTimeFieldNumber = 2;
  inline double shard_time() const;
  inline void set_shard_time(double value);

  // required int32 calls = 3;
  inline bool has_calls() const;
  inline void clear_calls();
  static const int kCallsFieldNumber = 3;
  inline ::google::protobuf::int32 calls() const;
  inline void set_calls(::google::protobuf::int32 value);

  // required int32 shard_calls = 4;
  inline bool has_shard_calls() const;
  inline void clear_shard_calls();
  static const int kShardCallsFieldNumber = 4;
  inline ::google::protobuf::int32 shard_calls() const;
  inline void set_shard_calls(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lapis.MethodStats)
 private:
  inline void set_has_total_time();
  inline void clear_has_total_time();
  inline void set_has_shard_time();
  inline void clear_has_shard_time();
  inline void set_has_calls();
  inline void clear_has_calls();
  inline void set_has_shard_calls();
  inline void clear_has_shard_calls();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double total_time_;
  double shard_time_;
  ::google::protobuf::int32 calls_;
  ::google::protobuf::int32 shard_calls_;
  friend void  protobuf_AddDesc_worker_2eproto();
  friend void protobuf_AssignDesc_worker_2eproto();
  friend void protobuf_ShutdownFile_worker_2eproto();

  void InitAsDefaultInstance();
  static MethodStats* default_instance_;
};
// -------------------------------------------------------------------

class HashGet : public ::google::protobuf::Message {
 public:
  HashGet();
  virtual ~HashGet();

  HashGet(const HashGet& from);

  inline HashGet& operator=(const HashGet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashGet& default_instance();

  void Swap(HashGet* other);

  // implements Message ----------------------------------------------

  HashGet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashGet& from);
  void MergeFrom(const HashGet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline ::google::protobuf::uint32 table() const;
  inline void set_table(::google::protobuf::uint32 value);

  // required uint32 shard = 2;
  inline bool has_shard() const;
  inline void clear_shard();
  static const int kShardFieldNumber = 2;
  inline ::google::protobuf::uint32 shard() const;
  inline void set_shard(::google::protobuf::uint32 value);

  // required uint32 source = 3;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 3;
  inline ::google::protobuf::uint32 source() const;
  inline void set_source(::google::protobuf::uint32 value);

  // optional bytes key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint32 index = 5;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:lapis.HashGet)
 private:
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_shard();
  inline void clear_has_shard();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 table_;
  ::google::protobuf::uint32 shard_;
  ::std::string* key_;
  ::google::protobuf::uint32 source_;
  ::google::protobuf::uint32 index_;
  friend void  protobuf_AddDesc_worker_2eproto();
  friend void protobuf_AssignDesc_worker_2eproto();
  friend void protobuf_ShutdownFile_worker_2eproto();

  void InitAsDefaultInstance();
  static HashGet* default_instance_;
};
// -------------------------------------------------------------------

class TableData : public ::google::protobuf::Message {
 public:
  TableData();
  virtual ~TableData();

  TableData(const TableData& from);

  inline TableData& operator=(const TableData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableData& default_instance();

  void Swap(TableData* other);

  // implements Message ----------------------------------------------

  TableData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableData& from);
  void MergeFrom(const TableData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline ::google::protobuf::uint32 source() const;
  inline void set_source(::google::protobuf::uint32 value);

  // required uint32 table = 2;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 2;
  inline ::google::protobuf::uint32 table() const;
  inline void set_table(::google::protobuf::uint32 value);

  // required uint32 shard = 3;
  inline bool has_shard() const;
  inline void clear_shard();
  static const int kShardFieldNumber = 3;
  inline ::google::protobuf::uint32 shard() const;
  inline void set_shard(::google::protobuf::uint32 value);

  // required bool done = 4;
  inline bool has_done() const;
  inline void clear_done();
  static const int kDoneFieldNumber = 4;
  inline bool done() const;
  inline void set_done(bool value);

  // required bytes key = 5;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 5;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes table_data = 6;
  inline bool has_table_data() const;
  inline void clear_table_data();
  static const int kTableDataFieldNumber = 6;
  inline const ::std::string& table_data() const;
  inline void set_table_data(const ::std::string& value);
  inline void set_table_data(const char* value);
  inline void set_table_data(const void* value, size_t size);
  inline ::std::string* mutable_table_data();
  inline ::std::string* release_table_data();
  inline void set_allocated_table_data(::std::string* table_data);

  // repeated .lapis.Arg kv_data = 7;
  inline int kv_data_size() const;
  inline void clear_kv_data();
  static const int kKvDataFieldNumber = 7;
  inline const ::lapis::Arg& kv_data(int index) const;
  inline ::lapis::Arg* mutable_kv_data(int index);
  inline ::lapis::Arg* add_kv_data();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::Arg >&
      kv_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::Arg >*
      mutable_kv_data();

  // optional bool missing_key = 8;
  inline bool has_missing_key() const;
  inline void clear_missing_key();
  static const int kMissingKeyFieldNumber = 8;
  inline bool missing_key() const;
  inline void set_missing_key(bool value);

  // @@protoc_insertion_point(class_scope:lapis.TableData)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_shard();
  inline void clear_has_shard();
  inline void set_has_done();
  inline void clear_has_done();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_table_data();
  inline void clear_has_table_data();
  inline void set_has_missing_key();
  inline void clear_has_missing_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 source_;
  ::google::protobuf::uint32 table_;
  ::std::string* key_;
  ::google::protobuf::uint32 shard_;
  bool done_;
  bool missing_key_;
  ::std::string* table_data_;
  ::google::protobuf::RepeatedPtrField< ::lapis::Arg > kv_data_;
  friend void  protobuf_AddDesc_worker_2eproto();
  friend void protobuf_AssignDesc_worker_2eproto();
  friend void protobuf_ShutdownFile_worker_2eproto();

  void InitAsDefaultInstance();
  static TableData* default_instance_;
};
// -------------------------------------------------------------------

class DiskData : public ::google::protobuf::Message {
 public:
  DiskData();
  virtual ~DiskData();

  DiskData(const DiskData& from);

  inline DiskData& operator=(const DiskData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiskData& default_instance();

  void Swap(DiskData* other);

  // implements Message ----------------------------------------------

  DiskData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiskData& from);
  void MergeFrom(const DiskData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 block_number = 1;
  inline bool has_block_number() const;
  inline void clear_block_number();
  static const int kBlockNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 block_number() const;
  inline void set_block_number(::google::protobuf::uint32 value);

  // required uint32 table = 2;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 2;
  inline ::google::protobuf::uint32 table() const;
  inline void set_table(::google::protobuf::uint32 value);

  // optional bool is_empty = 3;
  inline bool has_is_empty() const;
  inline void clear_is_empty();
  static const int kIsEmptyFieldNumber = 3;
  inline bool is_empty() const;
  inline void set_is_empty(bool value);

  // repeated .lapis.Arg records = 4;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 4;
  inline const ::lapis::Arg& records(int index) const;
  inline ::lapis::Arg* mutable_records(int index);
  inline ::lapis::Arg* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::lapis::Arg >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::lapis::Arg >*
      mutable_records();

  // @@protoc_insertion_point(class_scope:lapis.DiskData)
 private:
  inline void set_has_block_number();
  inline void clear_has_block_number();
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_is_empty();
  inline void clear_has_is_empty();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 block_number_;
  ::google::protobuf::uint32 table_;
  ::google::protobuf::RepeatedPtrField< ::lapis::Arg > records_;
  bool is_empty_;
  friend void  protobuf_AddDesc_worker_2eproto();
  friend void protobuf_AssignDesc_worker_2eproto();
  friend void protobuf_ShutdownFile_worker_2eproto();

  void InitAsDefaultInstance();
  static DiskData* default_instance_;
};
// -------------------------------------------------------------------

class FlushDiskTable : public ::google::protobuf::Message {
 public:
  FlushDiskTable();
  virtual ~FlushDiskTable();

  FlushDiskTable(const FlushDiskTable& from);

  inline FlushDiskTable& operator=(const FlushDiskTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlushDiskTable& default_instance();

  void Swap(FlushDiskTable* other);

  // implements Message ----------------------------------------------

  FlushDiskTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlushDiskTable& from);
  void MergeFrom(const FlushDiskTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 table = 1;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 1;
  inline ::google::protobuf::uint32 table() const;
  inline void set_table(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:lapis.FlushDiskTable)
 private:
  inline void set_has_table();
  inline void clear_has_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 table_;
  friend void  protobuf_AddDesc_worker_2eproto();
  friend void protobuf_AssignDesc_worker_2eproto();
  friend void protobuf_ShutdownFile_worker_2eproto();

  void InitAsDefaultInstance();
  static FlushDiskTable* default_instance_;
};
// ===================================================================


// ===================================================================

// RegisterWorkerRequest

// required int32 id = 1;
inline bool RegisterWorkerRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterWorkerRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterWorkerRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterWorkerRequest::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RegisterWorkerRequest::id() const {
  // @@protoc_insertion_point(field_get:lapis.RegisterWorkerRequest.id)
  return id_;
}
inline void RegisterWorkerRequest::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:lapis.RegisterWorkerRequest.id)
}

// -------------------------------------------------------------------

// ShardAssignment

// required int32 table = 1;
inline bool ShardAssignment::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShardAssignment::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShardAssignment::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShardAssignment::clear_table() {
  table_ = 0;
  clear_has_table();
}
inline ::google::protobuf::int32 ShardAssignment::table() const {
  // @@protoc_insertion_point(field_get:lapis.ShardAssignment.table)
  return table_;
}
inline void ShardAssignment::set_table(::google::protobuf::int32 value) {
  set_has_table();
  table_ = value;
  // @@protoc_insertion_point(field_set:lapis.ShardAssignment.table)
}

// required int32 shard = 2;
inline bool ShardAssignment::has_shard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShardAssignment::set_has_shard() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShardAssignment::clear_has_shard() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShardAssignment::clear_shard() {
  shard_ = 0;
  clear_has_shard();
}
inline ::google::protobuf::int32 ShardAssignment::shard() const {
  // @@protoc_insertion_point(field_get:lapis.ShardAssignment.shard)
  return shard_;
}
inline void ShardAssignment::set_shard(::google::protobuf::int32 value) {
  set_has_shard();
  shard_ = value;
  // @@protoc_insertion_point(field_set:lapis.ShardAssignment.shard)
}

// required int32 new_worker = 4;
inline bool ShardAssignment::has_new_worker() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShardAssignment::set_has_new_worker() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShardAssignment::clear_has_new_worker() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShardAssignment::clear_new_worker() {
  new_worker_ = 0;
  clear_has_new_worker();
}
inline ::google::protobuf::int32 ShardAssignment::new_worker() const {
  // @@protoc_insertion_point(field_get:lapis.ShardAssignment.new_worker)
  return new_worker_;
}
inline void ShardAssignment::set_new_worker(::google::protobuf::int32 value) {
  set_has_new_worker();
  new_worker_ = value;
  // @@protoc_insertion_point(field_set:lapis.ShardAssignment.new_worker)
}

// -------------------------------------------------------------------

// ShardAssignmentRequest

// repeated .lapis.ShardAssignment assign = 1;
inline int ShardAssignmentRequest::assign_size() const {
  return assign_.size();
}
inline void ShardAssignmentRequest::clear_assign() {
  assign_.Clear();
}
inline const ::lapis::ShardAssignment& ShardAssignmentRequest::assign(int index) const {
  // @@protoc_insertion_point(field_get:lapis.ShardAssignmentRequest.assign)
  return assign_.Get(index);
}
inline ::lapis::ShardAssignment* ShardAssignmentRequest::mutable_assign(int index) {
  // @@protoc_insertion_point(field_mutable:lapis.ShardAssignmentRequest.assign)
  return assign_.Mutable(index);
}
inline ::lapis::ShardAssignment* ShardAssignmentRequest::add_assign() {
  // @@protoc_insertion_point(field_add:lapis.ShardAssignmentRequest.assign)
  return assign_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::ShardAssignment >&
ShardAssignmentRequest::assign() const {
  // @@protoc_insertion_point(field_list:lapis.ShardAssignmentRequest.assign)
  return assign_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::ShardAssignment >*
ShardAssignmentRequest::mutable_assign() {
  // @@protoc_insertion_point(field_mutable_list:lapis.ShardAssignmentRequest.assign)
  return &assign_;
}

// -------------------------------------------------------------------

// ShardInfo

// required uint32 table = 1;
inline bool ShardInfo::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShardInfo::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShardInfo::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShardInfo::clear_table() {
  table_ = 0u;
  clear_has_table();
}
inline ::google::protobuf::uint32 ShardInfo::table() const {
  // @@protoc_insertion_point(field_get:lapis.ShardInfo.table)
  return table_;
}
inline void ShardInfo::set_table(::google::protobuf::uint32 value) {
  set_has_table();
  table_ = value;
  // @@protoc_insertion_point(field_set:lapis.ShardInfo.table)
}

// required uint32 shard = 2;
inline bool ShardInfo::has_shard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShardInfo::set_has_shard() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShardInfo::clear_has_shard() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShardInfo::clear_shard() {
  shard_ = 0u;
  clear_has_shard();
}
inline ::google::protobuf::uint32 ShardInfo::shard() const {
  // @@protoc_insertion_point(field_get:lapis.ShardInfo.shard)
  return shard_;
}
inline void ShardInfo::set_shard(::google::protobuf::uint32 value) {
  set_has_shard();
  shard_ = value;
  // @@protoc_insertion_point(field_set:lapis.ShardInfo.shard)
}

// required uint64 entries = 3;
inline bool ShardInfo::has_entries() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShardInfo::set_has_entries() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShardInfo::clear_has_entries() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShardInfo::clear_entries() {
  entries_ = GOOGLE_ULONGLONG(0);
  clear_has_entries();
}
inline ::google::protobuf::uint64 ShardInfo::entries() const {
  // @@protoc_insertion_point(field_get:lapis.ShardInfo.entries)
  return entries_;
}
inline void ShardInfo::set_entries(::google::protobuf::uint64 value) {
  set_has_entries();
  entries_ = value;
  // @@protoc_insertion_point(field_set:lapis.ShardInfo.entries)
}

// required uint32 owner = 4;
inline bool ShardInfo::has_owner() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShardInfo::set_has_owner() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShardInfo::clear_has_owner() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShardInfo::clear_owner() {
  owner_ = 0u;
  clear_has_owner();
}
inline ::google::protobuf::uint32 ShardInfo::owner() const {
  // @@protoc_insertion_point(field_get:lapis.ShardInfo.owner)
  return owner_;
}
inline void ShardInfo::set_owner(::google::protobuf::uint32 value) {
  set_has_owner();
  owner_ = value;
  // @@protoc_insertion_point(field_set:lapis.ShardInfo.owner)
}

// required int32 type = 5;
inline bool ShardInfo::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShardInfo::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShardInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShardInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ShardInfo::type() const {
  // @@protoc_insertion_point(field_get:lapis.ShardInfo.type)
  return type_;
}
inline void ShardInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:lapis.ShardInfo.type)
}

// -------------------------------------------------------------------

// MethodStats

// required double total_time = 1;
inline bool MethodStats::has_total_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MethodStats::set_has_total_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MethodStats::clear_has_total_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MethodStats::clear_total_time() {
  total_time_ = 0;
  clear_has_total_time();
}
inline double MethodStats::total_time() const {
  // @@protoc_insertion_point(field_get:lapis.MethodStats.total_time)
  return total_time_;
}
inline void MethodStats::set_total_time(double value) {
  set_has_total_time();
  total_time_ = value;
  // @@protoc_insertion_point(field_set:lapis.MethodStats.total_time)
}

// required double shard_time = 2;
inline bool MethodStats::has_shard_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MethodStats::set_has_shard_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MethodStats::clear_has_shard_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MethodStats::clear_shard_time() {
  shard_time_ = 0;
  clear_has_shard_time();
}
inline double MethodStats::shard_time() const {
  // @@protoc_insertion_point(field_get:lapis.MethodStats.shard_time)
  return shard_time_;
}
inline void MethodStats::set_shard_time(double value) {
  set_has_shard_time();
  shard_time_ = value;
  // @@protoc_insertion_point(field_set:lapis.MethodStats.shard_time)
}

// required int32 calls = 3;
inline bool MethodStats::has_calls() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MethodStats::set_has_calls() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MethodStats::clear_has_calls() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MethodStats::clear_calls() {
  calls_ = 0;
  clear_has_calls();
}
inline ::google::protobuf::int32 MethodStats::calls() const {
  // @@protoc_insertion_point(field_get:lapis.MethodStats.calls)
  return calls_;
}
inline void MethodStats::set_calls(::google::protobuf::int32 value) {
  set_has_calls();
  calls_ = value;
  // @@protoc_insertion_point(field_set:lapis.MethodStats.calls)
}

// required int32 shard_calls = 4;
inline bool MethodStats::has_shard_calls() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MethodStats::set_has_shard_calls() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MethodStats::clear_has_shard_calls() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MethodStats::clear_shard_calls() {
  shard_calls_ = 0;
  clear_has_shard_calls();
}
inline ::google::protobuf::int32 MethodStats::shard_calls() const {
  // @@protoc_insertion_point(field_get:lapis.MethodStats.shard_calls)
  return shard_calls_;
}
inline void MethodStats::set_shard_calls(::google::protobuf::int32 value) {
  set_has_shard_calls();
  shard_calls_ = value;
  // @@protoc_insertion_point(field_set:lapis.MethodStats.shard_calls)
}

// -------------------------------------------------------------------

// HashGet

// required uint32 table = 1;
inline bool HashGet::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HashGet::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HashGet::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HashGet::clear_table() {
  table_ = 0u;
  clear_has_table();
}
inline ::google::protobuf::uint32 HashGet::table() const {
  // @@protoc_insertion_point(field_get:lapis.HashGet.table)
  return table_;
}
inline void HashGet::set_table(::google::protobuf::uint32 value) {
  set_has_table();
  table_ = value;
  // @@protoc_insertion_point(field_set:lapis.HashGet.table)
}

// required uint32 shard = 2;
inline bool HashGet::has_shard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HashGet::set_has_shard() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HashGet::clear_has_shard() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HashGet::clear_shard() {
  shard_ = 0u;
  clear_has_shard();
}
inline ::google::protobuf::uint32 HashGet::shard() const {
  // @@protoc_insertion_point(field_get:lapis.HashGet.shard)
  return shard_;
}
inline void HashGet::set_shard(::google::protobuf::uint32 value) {
  set_has_shard();
  shard_ = value;
  // @@protoc_insertion_point(field_set:lapis.HashGet.shard)
}

// required uint32 source = 3;
inline bool HashGet::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HashGet::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HashGet::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HashGet::clear_source() {
  source_ = 0u;
  clear_has_source();
}
inline ::google::protobuf::uint32 HashGet::source() const {
  // @@protoc_insertion_point(field_get:lapis.HashGet.source)
  return source_;
}
inline void HashGet::set_source(::google::protobuf::uint32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:lapis.HashGet.source)
}

// optional bytes key = 4;
inline bool HashGet::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HashGet::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HashGet::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HashGet::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& HashGet::key() const {
  // @@protoc_insertion_point(field_get:lapis.HashGet.key)
  return *key_;
}
inline void HashGet::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:lapis.HashGet.key)
}
inline void HashGet::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:lapis.HashGet.key)
}
inline void HashGet::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lapis.HashGet.key)
}
inline ::std::string* HashGet::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lapis.HashGet.key)
  return key_;
}
inline ::std::string* HashGet::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HashGet::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lapis.HashGet.key)
}

// optional uint32 index = 5;
inline bool HashGet::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HashGet::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HashGet::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HashGet::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 HashGet::index() const {
  // @@protoc_insertion_point(field_get:lapis.HashGet.index)
  return index_;
}
inline void HashGet::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:lapis.HashGet.index)
}

// -------------------------------------------------------------------

// TableData

// required uint32 source = 1;
inline bool TableData::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableData::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableData::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableData::clear_source() {
  source_ = 0u;
  clear_has_source();
}
inline ::google::protobuf::uint32 TableData::source() const {
  // @@protoc_insertion_point(field_get:lapis.TableData.source)
  return source_;
}
inline void TableData::set_source(::google::protobuf::uint32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:lapis.TableData.source)
}

// required uint32 table = 2;
inline bool TableData::has_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableData::set_has_table() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableData::clear_has_table() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableData::clear_table() {
  table_ = 0u;
  clear_has_table();
}
inline ::google::protobuf::uint32 TableData::table() const {
  // @@protoc_insertion_point(field_get:lapis.TableData.table)
  return table_;
}
inline void TableData::set_table(::google::protobuf::uint32 value) {
  set_has_table();
  table_ = value;
  // @@protoc_insertion_point(field_set:lapis.TableData.table)
}

// required uint32 shard = 3;
inline bool TableData::has_shard() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableData::set_has_shard() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableData::clear_has_shard() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableData::clear_shard() {
  shard_ = 0u;
  clear_has_shard();
}
inline ::google::protobuf::uint32 TableData::shard() const {
  // @@protoc_insertion_point(field_get:lapis.TableData.shard)
  return shard_;
}
inline void TableData::set_shard(::google::protobuf::uint32 value) {
  set_has_shard();
  shard_ = value;
  // @@protoc_insertion_point(field_set:lapis.TableData.shard)
}

// required bool done = 4;
inline bool TableData::has_done() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableData::set_has_done() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableData::clear_has_done() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableData::clear_done() {
  done_ = false;
  clear_has_done();
}
inline bool TableData::done() const {
  // @@protoc_insertion_point(field_get:lapis.TableData.done)
  return done_;
}
inline void TableData::set_done(bool value) {
  set_has_done();
  done_ = value;
  // @@protoc_insertion_point(field_set:lapis.TableData.done)
}

// required bytes key = 5;
inline bool TableData::has_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TableData::set_has_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TableData::clear_has_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TableData::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& TableData::key() const {
  // @@protoc_insertion_point(field_get:lapis.TableData.key)
  return *key_;
}
inline void TableData::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:lapis.TableData.key)
}
inline void TableData::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:lapis.TableData.key)
}
inline void TableData::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lapis.TableData.key)
}
inline ::std::string* TableData::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lapis.TableData.key)
  return key_;
}
inline ::std::string* TableData::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TableData::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lapis.TableData.key)
}

// optional bytes table_data = 6;
inline bool TableData::has_table_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TableData::set_has_table_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TableData::clear_has_table_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TableData::clear_table_data() {
  if (table_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_data_->clear();
  }
  clear_has_table_data();
}
inline const ::std::string& TableData::table_data() const {
  // @@protoc_insertion_point(field_get:lapis.TableData.table_data)
  return *table_data_;
}
inline void TableData::set_table_data(const ::std::string& value) {
  set_has_table_data();
  if (table_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_data_ = new ::std::string;
  }
  table_data_->assign(value);
  // @@protoc_insertion_point(field_set:lapis.TableData.table_data)
}
inline void TableData::set_table_data(const char* value) {
  set_has_table_data();
  if (table_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_data_ = new ::std::string;
  }
  table_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:lapis.TableData.table_data)
}
inline void TableData::set_table_data(const void* value, size_t size) {
  set_has_table_data();
  if (table_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_data_ = new ::std::string;
  }
  table_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lapis.TableData.table_data)
}
inline ::std::string* TableData::mutable_table_data() {
  set_has_table_data();
  if (table_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    table_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:lapis.TableData.table_data)
  return table_data_;
}
inline ::std::string* TableData::release_table_data() {
  clear_has_table_data();
  if (table_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = table_data_;
    table_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TableData::set_allocated_table_data(::std::string* table_data) {
  if (table_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete table_data_;
  }
  if (table_data) {
    set_has_table_data();
    table_data_ = table_data;
  } else {
    clear_has_table_data();
    table_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:lapis.TableData.table_data)
}

// repeated .lapis.Arg kv_data = 7;
inline int TableData::kv_data_size() const {
  return kv_data_.size();
}
inline void TableData::clear_kv_data() {
  kv_data_.Clear();
}
inline const ::lapis::Arg& TableData::kv_data(int index) const {
  // @@protoc_insertion_point(field_get:lapis.TableData.kv_data)
  return kv_data_.Get(index);
}
inline ::lapis::Arg* TableData::mutable_kv_data(int index) {
  // @@protoc_insertion_point(field_mutable:lapis.TableData.kv_data)
  return kv_data_.Mutable(index);
}
inline ::lapis::Arg* TableData::add_kv_data() {
  // @@protoc_insertion_point(field_add:lapis.TableData.kv_data)
  return kv_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::Arg >&
TableData::kv_data() const {
  // @@protoc_insertion_point(field_list:lapis.TableData.kv_data)
  return kv_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::Arg >*
TableData::mutable_kv_data() {
  // @@protoc_insertion_point(field_mutable_list:lapis.TableData.kv_data)
  return &kv_data_;
}

// optional bool missing_key = 8;
inline bool TableData::has_missing_key() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TableData::set_has_missing_key() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TableData::clear_has_missing_key() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TableData::clear_missing_key() {
  missing_key_ = false;
  clear_has_missing_key();
}
inline bool TableData::missing_key() const {
  // @@protoc_insertion_point(field_get:lapis.TableData.missing_key)
  return missing_key_;
}
inline void TableData::set_missing_key(bool value) {
  set_has_missing_key();
  missing_key_ = value;
  // @@protoc_insertion_point(field_set:lapis.TableData.missing_key)
}

// -------------------------------------------------------------------

// DiskData

// required uint32 block_number = 1;
inline bool DiskData::has_block_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskData::set_has_block_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiskData::clear_has_block_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiskData::clear_block_number() {
  block_number_ = 0u;
  clear_has_block_number();
}
inline ::google::protobuf::uint32 DiskData::block_number() const {
  // @@protoc_insertion_point(field_get:lapis.DiskData.block_number)
  return block_number_;
}
inline void DiskData::set_block_number(::google::protobuf::uint32 value) {
  set_has_block_number();
  block_number_ = value;
  // @@protoc_insertion_point(field_set:lapis.DiskData.block_number)
}

// required uint32 table = 2;
inline bool DiskData::has_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskData::set_has_table() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiskData::clear_has_table() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiskData::clear_table() {
  table_ = 0u;
  clear_has_table();
}
inline ::google::protobuf::uint32 DiskData::table() const {
  // @@protoc_insertion_point(field_get:lapis.DiskData.table)
  return table_;
}
inline void DiskData::set_table(::google::protobuf::uint32 value) {
  set_has_table();
  table_ = value;
  // @@protoc_insertion_point(field_set:lapis.DiskData.table)
}

// optional bool is_empty = 3;
inline bool DiskData::has_is_empty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiskData::set_has_is_empty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiskData::clear_has_is_empty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiskData::clear_is_empty() {
  is_empty_ = false;
  clear_has_is_empty();
}
inline bool DiskData::is_empty() const {
  // @@protoc_insertion_point(field_get:lapis.DiskData.is_empty)
  return is_empty_;
}
inline void DiskData::set_is_empty(bool value) {
  set_has_is_empty();
  is_empty_ = value;
  // @@protoc_insertion_point(field_set:lapis.DiskData.is_empty)
}

// repeated .lapis.Arg records = 4;
inline int DiskData::records_size() const {
  return records_.size();
}
inline void DiskData::clear_records() {
  records_.Clear();
}
inline const ::lapis::Arg& DiskData::records(int index) const {
  // @@protoc_insertion_point(field_get:lapis.DiskData.records)
  return records_.Get(index);
}
inline ::lapis::Arg* DiskData::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:lapis.DiskData.records)
  return records_.Mutable(index);
}
inline ::lapis::Arg* DiskData::add_records() {
  // @@protoc_insertion_point(field_add:lapis.DiskData.records)
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::lapis::Arg >&
DiskData::records() const {
  // @@protoc_insertion_point(field_list:lapis.DiskData.records)
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::lapis::Arg >*
DiskData::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:lapis.DiskData.records)
  return &records_;
}

// -------------------------------------------------------------------

// FlushDiskTable

// required uint32 table = 1;
inline bool FlushDiskTable::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlushDiskTable::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlushDiskTable::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlushDiskTable::clear_table() {
  table_ = 0u;
  clear_has_table();
}
inline ::google::protobuf::uint32 FlushDiskTable::table() const {
  // @@protoc_insertion_point(field_get:lapis.FlushDiskTable.table)
  return table_;
}
inline void FlushDiskTable::set_table(::google::protobuf::uint32 value) {
  set_has_table();
  table_ = value;
  // @@protoc_insertion_point(field_set:lapis.FlushDiskTable.table)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace lapis

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_worker_2eproto__INCLUDED
